{"meta":{"title":"夏晓文的博客","subtitle":"","description":"keep walking","author":"夏晓文","url":"https://xiaowenxia.github.io/git-inside","root":"/git-inside/"},"pages":[],"posts":[{"title":"Git 目录结构","slug":"git-layout","date":"2021-02-16T03:56:24.000Z","updated":"2021-02-17T10:53:28.000Z","comments":true,"path":"2021/02/16/git-layout/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2021/02/16/git-layout/","excerpt":"","text":"Git 目录结构Git 仓库有两种形式： 工作目录中的 .git 目录。这种是我们经常接触的Git仓库形式。 裸仓库，目录一般是 &lt;project&gt;.git。裸仓库没有工作区（working tree），一般是存在于服务器中，用于给用户仓库交互和存储的。 注：有些仓库底下没有.git目录，但是有一个 .git 文本文件，其内容格式为 gitdir: &lt;path&gt; ，代表指向真正的 .git 目录。这种情况经常用在 git submodule 中。 Git 仓库文件结构objects/仓库的所有对象都存储在objects/目录中。 定义了 GIT_COMMON_DIR 环境变量时， objects/ 目录路径则为：$GIT_COMMON_DIR/objects。 一般来讲，objects/ 目录中记录了所有的仓库对象，但是有些特殊情况（存在 objects/info/alternates 文件，或者定义 GIT_ALTERNATE_OBJECT_DIRECTORIES 环境变量时），可以引用仓库外部的对象，具体参见：gitrepository-layout.txt#L40。 objects/[0-9a-f][0-9a-f]/松散对象（’unpacked’ or ‘loose’ objects）。新创建的对象都是存在这些目录中，对象的文件名称时对象内容的sha1值，取sha1值的前2个字符作为子目录。 objects/pack/pack文件存储位置。该目录下还存在 *.idx 文件，为对应的 *.pack 文件的索引文件。 objects/info/记录objects 目录的说明。 objects/info/packsgit 哑协议（dumb transports）会使用到的文件。 objects/info/alternates该文件记录外部对象目录，一行记录一个目录路径。 objects/info/http-alternates当仓库是HTTP协议传输时，该文件记录的是URLs，这些URLs存储外部的对象。 refs/git 引用，该目录下存储 git 的所有引用。git prune 命令会清除掉那些不被 git references 引用到的对象。 定义了 GIT_COMMON_DIR 环境变量时， refs/ 目录路径则为：$GIT_COMMON_DIR/refs/，但是 refs/bisect 、 refs/rewritten 、 refs/worktree 这3个文件不会受 GIT_COMMON_DIR 影响。 refs/heads/记录 git 的分支（branch）。 refs/tags/记录 git 的标签（tag）。 refs/remotes/记录远程分支。 refs/replace/records the SHA-1 of the object that replaces &lt;obj-sha1&gt;. packed-refs/记录的和 refs/heads/, refs/tags/ 一样的内容，但是记录效率更高。 跟refs/ 目录一样，定义了 GIT_COMMON_DIR 环境变量时， packed-refs/ 目录路径则为：$GIT_COMMON_DIR/packed-refs/ HEAD记录当前激活的分支，其内容指向具体的分支（refs/heads/&lt;name&gt;）。一个git仓库一定会有一个HEAD文件。HEAD 文件也可以直接记录一个commit-id，这种情况就是常见的’detached HEAD.’，当检出特定的commit-id时（ git checkout &lt;commit-id&gt; ）就会变成这样。 很多时候可以通过HEAD文件来判断仓库的默认分支。 HEAD指向不存在的分支也是可以的。 config本地仓库配置，通过git config --local查看或者设置。该文件的路径也受环境变量 GIT_COMMON_DIR 控制。 config.worktree多工作区时的工作区配置文件。 branches/用于 ‘git fetch’ 、 ‘git pull’ 、 ‘git push’，不过这个目录已经不再用了。 hooks/git 钩子目录。 git init 时，会默认创建一些简单的 hooks 文件。该目录也受环境变量 GIT_COMMON_DIR 控制。 common/当仓库是多工作区时，不同的工作区共享 common/ 目录下的文件。 index索引文件，裸仓库（bare repository）下不存在 index 文件。 sharedindex.共享索引文件（shared index ），被index文件或者临时index文件（temporary index）引用。只在分割索引模式（split index mode）中有效。 info/仓库描述信息目录。文件目录受环境变量 GIT_COMMON_DIR 控制。 info/refs跟objects/info/packs一样，用于哑协议。 info/graftsinfo/exclude一般情况，这个文件描述哪些文件排除在版本控制之外，和 .gitignore 文件功能类似，但是 .gitignore 文件可以存在每个目录下面。 info/attributes定义路径的属性，和.gitattributes文件功能类似。 info/sparse-checkout记录 sparse checkout 时的匹配信息。 remotes记录 ‘git fetch’ 、 ‘git pull’ 、 ‘git push’ 命令时的远程 URL 和引用名称。这个目录现在已经不用了。 logs/存储引用的历史变更记录。该目录也受环境变量 GIT_COMMON_DIR 控制，不过 logs/HEAD 文件除外。 logs/refs/heads/&lt;name&gt;分支的历史变更记录。 logs/refs/tags/&lt;name&gt;标签的历史变更记录。 shallow跟 info/grafts 一样的功能，但是只用于内部。 commondir该文件存在时，如果没有定义 GIT_COMMON_DIR 环境变量，那 GIT_COMMON_DIR 会被设置成commondir的内容。 modules存储 git submodule 的仓库。 worktreesworktrees/&lt;id&gt;/gitdirworktrees/&lt;id&gt;/lockedworktrees/&lt;id&gt;/config.worktree仓库目录 gitrepository-layout","categories":[],"tags":[]},{"title":"Git 底层原理：Git 底层文件存储格式","slug":"git-internal.file-struct","date":"2020-12-06T09:12:56.000Z","updated":"2021-02-16T08:42:24.000Z","comments":true,"path":"2020/12/06/git-internal.file-struct/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/12/06/git-internal.file-struct/","excerpt":"","text":"Git 底层原理：Git 底层文件存储格式Git 底层文件有 Git 对象、索引文件、pack 文件、分支/引用、HEAD指针等，在《Git 底层原理： Git 对象》里面有讲解到，Git 是一个文件系统，最小单元是 Git 对象，Git 对象又分为 4种：blob、tree、commit、tag，那这些对象具体是以什么形式存储的？ 首先按照《Git 底层原理： Git 对象》里面提到的步骤初始化一个简单的 git 仓库，查看生成的 git 对象： 1234567891011$ find .git/objects -type f | sort.git/objects/03/2ddd9205d65abd773af1610038c764f46a0b12 # tag.git/objects/10/da3741b6e365b6795335e1e2d3ed5820e794cd # tree | 第二次提交.git/objects/39/fb0fbcac51f66b514fbd589a5b2bc0809ce664 # tree: doc/ | 第二次提交.git/objects/41/20b5f61a582cb12d4dcdaab71c7ef1862dbbca # tree | 第一次提交.git/objects/45/c7a584f300657dba878a542a6ab3b510b63aa3 # blob | changelog.git/objects/52/3d41ce82ea993e7c7df8be1292b2eac84d4659 # commit | 第一次提交.git/objects/56/64e303b5dc2e9ef8e14a0845d9486ec1920afd # blob | README.md.git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85 # blob | 第一次提交 | file.txt.git/objects/a0/e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0 # commit | 第二次提交.git/objects/ae/c2e48cbf0a881d893ccdd9c0d4bbaf011b5b23 # blob | 第二次提交 | file.txt Git 对象为了减少存储大小，git 对象都是使用 zlib 压缩存储的。git 对象由 &lt;type&gt; + &lt;size&gt; + &lt;content&gt; 组成： &lt;type&gt;: git 对象类型，有如下 4 种：blob、tree、commit、tag。 &lt;size&gt;: git 对象的内容大小。 &lt;content&gt;: git 对象内容。 如下是 4 种对象的数据存储格式： 这里可能会有人有疑惑，Git 对象并没有对自身数据做校验（checksum），这样会不会有人对数据进行修改？这个其实不用担心，所有的 Git 对象都会组成一个图（Graph），按照指向关系可以这么理解：refs –&gt; tag 对象 –&gt; commit 对象 –&gt; tree 对象 –&gt; blob 对象（实际上更为复杂），对象之间通过对方的 sha1 值来确定指向关系，所以要是篡改了对象的内容，那指向关系就会被破坏掉，git fsck 命令就会提示 &quot;hash mismatch&quot;。 查看对象存储格式git 提供了 cat-file 来解析 git 对象，并输出格式化可阅读的内容： 12345678910111213# 查看对象内容$ git cat-file -p 6fb38100644 blob 5664e303b5dc2e9ef8e14a0845d9486ec1920afd README.md040000 tree 39fb0fbcac51f66b514fbd589a5b2bc0809ce664 doc100644 blob aec2e48cbf0a881d893ccdd9c0d4bbaf011b5b23 file.txt# 查看对象类型$ git cat-file -t 6fb38tree#查看对象存储的内容大小$ git cat-file -s 6fb38103 同时，cat-file 也支持输出未格式化的内容： 12345# 查看未格式化的内容$ git cat-file tree 10da374100644 README.mdVd���.���E�Hn���40000 doc9���Q�kQO�X�[+����d100644 file.txt��䌿��&lt;���Ի�% 如果你想要不依赖 git 命令来查看 git 对象，可以使用 zlib 的一个解压工具：zlib-flate 来解压 git 对象，以 file.txt 第一次提交生成的 blob 对象 6fb38b7 为例： 12$ zlib-flate -uncompress &lt; .git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85blob 11git-inside 根据上面的 blob 存储格式可以知道，其中 &quot;blob&quot; 是对象类型，&quot;11&quot; 是文件大小，&quot;git-inside&quot; 是文件内容。 这里提供一下 4 种对象的原始数据，仅供参考： 12345678910111213141516171819202122232425262728293031# 查看 blob 对象内容$ zlib-flate -uncompress &lt; .git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85blob 11git-inside# 查看 tree 对象内容，因为内容是二进制格式，这里使用 hexdump 格式化输出$ zlib-flate -uncompress &lt; .git/objects/10/da3741b6e365b6795335e1e2d3ed5820e794cd | hexdump -C00000000 74 72 65 65 20 31 30 33 00 31 30 30 36 34 34 20 |tree 103.100644 |00000010 52 45 41 44 4d 45 2e 6d 64 00 56 64 e3 03 b5 dc |README.md.Vd....|00000020 2e 9e f8 e1 4a 08 45 d9 48 6e c1 92 0a fd 34 30 |....J.E.Hn....40|00000030 30 30 30 20 64 6f 63 00 39 fb 0f bc ac 51 f6 6b |000 doc.9....Q.k|00000040 51 4f bd 58 9a 5b 2b c0 80 9c e6 64 31 30 30 36 |QO.X.[+....d1006|00000050 34 34 20 66 69 6c 65 2e 74 78 74 00 ae c2 e4 8c |44 file.txt.....|00000060 bf 0a 88 1d 89 3c cd d9 c0 d4 bb af 01 1b 5b 23 |.....&lt;........[#|# 查看 commit 对象内容$ zlib-flate -uncompress &lt; .git/objects/a0/e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0commit 220tree 10da3741b6e365b6795335e1e2d3ed5820e794cdparent 523d41ce82ea993e7c7df8be1292b2eac84d4659author xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800committer xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800second commit# 查看 tag 对象内容$ zlib-flate -uncompress &lt; .git/objects/03/2ddd9205d65abd773af1610038c764f46a0b12tag 148object a0e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0type committag v0.0.2tagger xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800this is annotated tag 这里使用到了 hexdump，hexdump 是一个 UNIX 命令，用来格式化输出二进制数据。 索引文件索引文件默认路径为：.git/index。索引文件用来存储暂存区的相关文件信息，当运行 git add 命令时会把工作区的变更文件信息添加到该索引文件中。索引文件以如下的格式存储暂存区内容： 读过源码的同学会发现，其实还有一个叫.git/index.lock的文件，该文件存在时表示当前工作区被锁定，代表有 git 进程正在操作该仓库。 查看索引文件存储格式使用 ls-files 可以读取索引文件存储的文件信息： 1234$ git ls-files --stage100644 5664e303b5dc2e9ef8e14a0845d9486ec1920afd 0 README.md100644 45c7a584f300657dba878a542a6ab3b510b63aa3 0 doc/changelog100644 aec2e48cbf0a881d893ccdd9c0d4bbaf011b5b23 0 file.txt 当然，ls-files 的输出内容也是经过格式化的。跟 Git 对象 不一样，索引文件 .git/indx 并没有经过 zlib 压缩，使用 hexdump 工具就可以直接查看原始数据： 123456789101112131415161718192021$ hexdump -C .git&#x2F;index00000000 44 49 52 43 00 00 00 02 00 00 00 03 5f cb 65 22 |DIRC........_.e&quot;|00000010 22 be 40 2c 5f cb 65 22 22 be 40 2c 01 00 00 04 |&quot;.@,_.e&quot;&quot;.@,....|00000020 01 3e 09 e3 00 00 81 a4 00 00 01 f6 00 00 00 14 |.&gt;..............|00000030 00 00 00 04 56 64 e3 03 b5 dc 2e 9e f8 e1 4a 08 |....Vd........J.|00000040 45 d9 48 6e c1 92 0a fd 00 09 52 45 41 44 4d 45 |E.Hn......README|00000050 2e 6d 64 00 5f cb 65 26 01 bd 63 4e 5f cb 65 26 |.md._.e&amp;..cN_.e&amp;|00000060 01 bd 63 4e 01 00 00 04 01 3e 09 f4 00 00 81 a4 |..cN.....&gt;......|00000070 00 00 01 f6 00 00 00 14 00 00 00 07 45 c7 a5 84 |............E...|00000080 f3 00 65 7d ba 87 8a 54 2a 6a b3 b5 10 b6 3a a3 |..e&#125;...T*j....:.|00000090 00 0d 64 6f 63 2f 63 68 61 6e 67 65 6c 6f 67 00 |..doc&#x2F;changelog.|000000a0 00 00 00 00 5f cb 65 1f 17 f9 45 e9 5f cb 65 1f |...._.e...E._.e.|000000b0 17 f9 45 e9 01 00 00 04 01 3e 08 92 00 00 81 a4 |..E......&gt;......|000000c0 00 00 01 f6 00 00 00 14 00 00 00 1a ae c2 e4 8c |................|000000d0 bf 0a 88 1d 89 3c cd d9 c0 d4 bb af 01 1b 5b 23 |.....&lt;........[#|000000e0 00 08 66 69 6c 65 2e 74 78 74 00 00 54 52 45 45 |..file.txt..TREE|000000f0 00 00 00 35 00 33 20 31 0a 10 da 37 41 b6 e3 65 |...5.3 1...7A..e|00000100 b6 79 53 35 e1 e2 d3 ed 58 20 e7 94 cd 64 6f 63 |.yS5....X ...doc|00000110 00 31 20 30 0a 39 fb 0f bc ac 51 f6 6b 51 4f bd |.1 0.9....Q.kQO.|00000120 58 9a 5b 2b c0 80 9c e6 64 ac 8f 88 7a 1e a4 d0 |X.[+....d...z...|00000130 b9 83 8d 83 72 4e 7b 71 d2 d8 a0 a5 3d |....rN&#123;q....&#x3D;| 索引文件大部分内容都是以二进制存储的，可读性很差，喜欢钻研的同学可以去看源码。 pack 文件pack文件用来合并压缩多个object对象的，可以方便进行网络传输（推送到远程仓库）。*.pack 文件格式： 该图片来自于：https://developer.aliyun.com/article/761663 。 *.idx 文件格式： 该图片来自于：https://developer.aliyun.com/article/761663 。 HEAD 等指针文件HEAD 具体路径为 .git/HEAD ，HEAD 实际上是一个指针，指向具体的引用或者 commit-id ，比如 HEAD 指向 master 分支时是如下内容： 12$ cat .git/HEADref: refs/heads/master 如果 checkout 了一个特定的 commit-id 时，那 HEAD 的值是这个 commit-id。 123$ git checkout 523d41ce82ea993e7c7df8be1292b2eac84d4659$ cat .git/HEAD523d41ce82ea993e7c7df8be1292b2eac84d4659 另外，如果我 checkout 了指定的 tag 时，那 HEAD 的值是这个 tag 对应的 commit-id。同样的，.git/ORIG_HEAD、.git/FETCH_HEAD 也是这样的存储方式。 引用Git 引用名义上是指针，实际上是一个很简单的文件，这个文件存储的是指向的提交的 commit-id： 12$ cat .git/refs/heads/mastera0e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0 附录相关的 Git 源码 基于 git v2.29.2 版本。 Git 对象： 写入 Git 对象源码： sha1-file.c &gt; write_object_file()。 读取 Git 对象源码： sha1-file.c &gt; read_object_file_extended() 索引文件： 解析 索引文件：read-cache.c &gt; read_index_from 工作区锁定：lockfile.c。 1234567891011121314151617181920/* 索引文件 header */struct cache_header &#123; uint32_t hdr_signature; uint32_t hdr_version; uint32_t hdr_entries;&#125;;/* 文件（entry）的存储格式 */struct ondisk_cache_entry &#123; struct cache_time ctime; struct cache_time mtime; uint32_t dev; uint32_t ino; uint32_t mode; uint32_t uid; uint32_t gid; uint32_t size; unsigned char data[GIT_MAX_RAWSZ + 2 * sizeof(uint16_t)]; char name[FLEX_ARRAY];&#125;; 参考资料 https://stackoverflow.com/questions/14790681/what-is-the-internal-format-of-a-git-tree-object https://stackoverflow.com/questions/4084921/what-does-the-git-index-contain-exactly https://gist.github.com/masak/2415865 https://linux.die.net/man/1/git-pack-objects","categories":[],"tags":[]},{"title":"Git 底层原理：Git 对象","slug":"git-internal.objects","date":"2020-12-06T09:05:03.000Z","updated":"2021-02-16T08:32:44.000Z","comments":true,"path":"2020/12/06/git-internal.objects/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/12/06/git-internal.objects/","excerpt":"","text":"Git 底层原理：Git 对象git 实际上是一个内容文件系统，载体是 git 的对象，存储的是一个个的内容版本。git 仓库就像一个书架，书架上放着的是一本本书，对于 git 来讲，这一本本书就是 git 对象，存储的是书的每一个版本的内容。 Git 对象 是 Git 的最小组成单位，git 的所有核心底层命令实际上都是在操作 git 对象。比如 git add 命令，就是把文件快照存储成 blob 对象，git commit 命令，就是把提交的文件列表和提交信息分别存储成 tree 对象和 commit 对象，git checkout -b创建分支命令，就是创建一个指针指向 commit 对象。 本文会从一个空的仓库开始，一步一步由浅入深的展开讲解 git 的内部原理以及底层对象。 0x01 首先初始化工程123456789101112131415161718192021# 初始化工程$ git initInitialized empty Git repository in /Users/xxx/workspace/git-inside/.git/# 查看目录结构$ tree -a└── .git ├── HEAD ├── config ├── description ├── hooks │ ├── applypatch-msg.sample │ ├── ...... # 省略 │ └── update.sample ├── info │ └── exclude ├── objects │ ├── info │ └── pack └── refs ├── heads └── tags git 初始化时，实际上是在仓库下创建了一个 .git 目录的隐藏目录，以及一些默认的文件： HEAD: HEAD 指针，指向当前的操作分支，具体看 HEAD。 config: 存储的本地仓库的配置，具体看 git 的配置说明。 description: 用来存储仓库名称以及仓库的描述信息。具体看 ./git/description。 hooks/*: git 钩子，git 钩子可以做非常有用的事情，也是构建 git 工作流中不可或缺的部分。具体看 git 钩子。 info/exclude: 该文件的功能和 .gitignore 一样，都是配置 git 忽略本地文件。 objects/*: git 的底层对象，具体看 git 底层对象。 refs/heads 和 refs/tags : git 引用，实现了git 的分支策略，具体看 git 引用。 实际上还有更多不常用的文件和目录，更详细的细节可以查阅：Git Repository Layout。 0x02 添加一个文件使用 git add 命令把当前工作区的变更提交到暂存区： 12345# 添加文件$ echo &quot;git-inside&quot; &gt; file.txt# 把文件添加到暂存区中$ git add file.txt 此时查看 .git/ 工作目录： 12$ find .git/objects -type f.git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85 可以看到新生成了一个 git 对象，路径为.git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85。 git 对象的文件路径和名称根据文件内容的 sha1 值决定，取 sha1 值的第一个字节的 hex 值为目录，其他字节的 hex 值为名称。这里使用这种方式存储 Git 对象有 2 个好处： 对 Git 对象做完整性校验。 快速遍历/查找 Git 对象。 为了减少存储大小，git 对象都是使用 zlib 压缩存储的。git 对象的详细说明可以参考这里：git 对象 。git 提供了 cat-file 命令用来格式化查看 git 对象内容： 123456# 查看 git 对象内容$ git cat-file -p 6fb38b7118b554886e96fa736051f18d63a80c85git-inside# 查看 git 对象类型$ git cat-file -t 6fb38b7118b554886e96fa736051f18d63a80c85blob 可以看到 6fb38b7（上述 git 对象的 sha1 值简写） 对象类型为 blob 对象，blob 对象存储变更文件的内容快照。 根据 sha1 的散列特性，使用 sha1 的前 7 个字符就基本可以表示该 sha1 值。Github、Gitlab 也一样。 此时查看 .git/ 目录下，会新增一个 index 文件（索引文件）： 12$ file .git/index.git/index: Git index, version 2, 1 entries index 文件存储暂存区的文件列表，index文件代表了 git 的一个重要的概念：暂存区。index 文件的详细说明可以查看 索引文件 。index 文件使用二进制方式存储暂存区信息，通过 git 提供的 ls-file 底层命令可以查看索引文件的格式化输出： 12$ git ls-files -tH file.txt 有兴趣的同学可以使用 hexdump -C 命令查看索引文件的二进制内容。 0x03 提交到本地版本库使用 git commit 命令可以把暂存区的变动提交到本地版本库中： 1234$ git commit -m &quot;first commit&quot;[master (root-commit) 523d41c] first commit 1 file changed, 1 insertion(+) create mode 100644 file.txt 其中 100644 是指的文件模式，100644 表明这是一个普通文件。 其他情况比如 100755 表示可执行文件，120000 表示符号链接。 如果你是边阅读本文边动手操作，那你会发现生成的 commit 对象的 sha1 值跟本文不一致，因为提交日期以及用户名邮箱是不一样的，可以点击这里 设置固定的时间日期、用户名和邮箱，这样提交的对象就会是一样的 sha1值，也方便阅读本文。 查看 .git/objects 目录下，会新增 2 个 git 对象： 1234$ find .git/objects -type f.git/objects/41/20b5f61a582cb12d4dcdaab71c7ef1862dbbca.git/objects/52/3d41ce82ea993e7c7df8be1292b2eac84d4659.git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85 分别是 523d41c 和 4120b5f 。 使用 git cat-file 可以看到 2 个 对象的类型和内容： 123456789101112131415# 523d41c 是一个 commit 对象$ git cat-file -t 523d41ccommit$ git cat-file -p 523d41ctree 4120b5f61a582cb12d4dcdaab71c7ef1862dbbcaauthor xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800committer xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800first commit# 4120b5f 是一个 tree 对象$ git cat-file -t 4120b5fcommit$ git cat-file -p 4120b5f100644 blob 6fb38b7118b554886e96fa736051f18d63a80c85 file.txt 也可以使用 git cat-file -p 523d41c^&#123;tree&#125; 来查看 4120b5f 的内容，523d41c^&#123;tree&#125; 和 4120b5f 是等效的，更多请查看 git revisions。 这里新出现了 2 种新的 git 对象类型，分别是 tree 对象（523d41c） 和 commit 对象（4120b5f），tree 对象用来记录目录结构和 blob 对象索引，commit 对象包含着指向前述 tree 对象的指针和所有提交信息。 操作到这里，git 的底层对象一共生成了 3 个，分别是： 6fb38b7: blob 对象。 4120b5f: tree 对象，指向 6fb38b7。 523d41c: commit 对象，指向 4120b5f。 他们之间的关系是： 0x04 提交第二个版本我们继续提交代码和文件： 123456789$ echo &quot;append content&quot; &gt;&gt; file.txt$ echo &quot;git&quot; &gt; README.md$ mkdir doc &amp;&amp; echo &quot;v0.0.1&quot; &gt; doc/changelog$ git add -A$ git commit -m &quot;second commit&quot;[master a0e96b5] second commit 3 files changed, 3 insertions(+) create mode 100644 README.md create mode 100644 doc/changelog 该提交为 file.txt 添加了内容，同时新增了子目录：doc/，并新增了 README.md 和 doc/changelog 2个文件。查看 git 对象列表： 12345678910$ find .git/objects -type f | sort.git/objects/10/da3741b6e365b6795335e1e2d3ed5820e794cd # tree | 第二次提交.git/objects/39/fb0fbcac51f66b514fbd589a5b2bc0809ce664 # tree: doc/ | 第二次提交.git/objects/41/20b5f61a582cb12d4dcdaab71c7ef1862dbbca # tree | 第一次提交.git/objects/45/c7a584f300657dba878a542a6ab3b510b63aa3 # blob | changelog.git/objects/52/3d41ce82ea993e7c7df8be1292b2eac84d4659 # commit | 第一次提交.git/objects/56/64e303b5dc2e9ef8e14a0845d9486ec1920afd # blob | README.md.git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85 # blob | 第一次提交 | file.txt.git/objects/a0/e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0 # commit | 第二次提交.git/objects/ae/c2e48cbf0a881d893ccdd9c0d4bbaf011b5b23 # blob | 第二次提交 | file.txt 可以看到除了原先的 6fb38b7、4120b5f、523d41c，又新增了： 10da374: tree 对象，指向 README.md ( 5664e30 ) 、file.txt ( aec2e48 )、doc/ ( 39fb0fb )。 39fb0fb: tree 对象，指向 changelog ( 45c7a58 )。 45c7a58: blob 对象， 存储 changelog 内容快照。 5664e30: blob 对象，存储 README.md 内容快照。 a0e96b5: commit 对象，指向 10da374、523d41c。 aec2e48: blob 对象，存储更改的 file.txt 内容快照。 查看新增的 2 个 tree 对象： 1234567$ git cat-file -p 10da374100644 blob 5664e303b5dc2e9ef8e14a0845d9486ec1920afd README.md040000 tree 39fb0fbcac51f66b514fbd589a5b2bc0809ce664 doc100644 blob aec2e48cbf0a881d893ccdd9c0d4bbaf011b5b23 file.txt$ git cat-file -p 39fb0fb100644 blob 45c7a584f300657dba878a542a6ab3b510b63aa3 changelog 这里有必要说明一下，Git 使用 tree 对象来存储目录结构，不同的目录对应不同的 tree 对象，这次提交里面，顶层目录对应的 tree 是 10da374，doc/ 目录对应的 tree 是 39fb0fb。 继续查看 commit 对象 a0e96b5 内容： 1234567$ git cat-file -p a0e96b5tree 10da3741b6e365b6795335e1e2d3ed5820e794cdparent 523d41ce82ea993e7c7df8be1292b2eac84d4659author xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800committer xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800second commit 仔细的同学会发现，a0e96b5 跟第一次提交生成的 commit 对象（523d41c）相比，多了一个 parent 字段。parent 字段是用来指向上一次提交的，一般是1个 parent ，有些情况下会是多个 parent ，比如 merge 这种情况。 我们再总结一下这些对象之间的关系： 如图所示，每一次提交可以是一个文件，也可以是多个文件和多个目录，一次提交就是一次版本（ revision ）。同时这里又引申出来了 git 的一个非常重要的概念，每一次新的提交都会指向上一个提交，这样多个提交就组成了一个提交链。这个提交链使用到了一个非常有名的算法：merkle tree，感兴趣的同学可以去深入了解，这里就不深入讲解了。merkle tree 有一个重要的特性就是单独更改其中一个节点的内容就会破坏掉这个tree，也就是说 merkle tree 的节点是不可更改的。git 就是通过 merkle tree 来保证每个版本都是连续有效的。 这就是为什么很难修改 git 的历史提交记录的原因，如果要修改某一个提交，那同时还需要修改这个提交之后的所有提交，这样才能保证 merkle tree 是有效成立的。另外，区块链也是基于 merkle tree 来保证数据可靠性的。 可以猜想一下，如果继续提交代码，那 git 对象会是如下的关系： 按照先后时间顺序单独看 commit 对象之间的关系： 这个 commit 对象关系图非常重要，git 分支策略就是围绕着这个关系图来运作的，这里暂且不做展开。 0x05 打标签上面的操作涉及了 3 种 git 对象，分别是 blob、tree、commit 对象，其实 git 还存在一个 tag 类型的对象，用来存储带注释的标签。使用如下命令创建标签： 123456789101112131415161718192021$ git tag &quot;v0.0.2&quot; -m &quot;this is annotated tag&quot;# 查看 git 对象和引用$ find .git/objects -type f | sort.git/objects/03/2ddd9205d65abd773af1610038c764f46a0b12 # tag.git/objects/10/da3741b6e365b6795335e1e2d3ed5820e794cd # tree | 第二次提交.git/objects/39/fb0fbcac51f66b514fbd589a5b2bc0809ce664 # tree: doc/ | 第二次提交.git/objects/41/20b5f61a582cb12d4dcdaab71c7ef1862dbbca # tree | 第一次提交.git/objects/45/c7a584f300657dba878a542a6ab3b510b63aa3 # blob | changelog.git/objects/52/3d41ce82ea993e7c7df8be1292b2eac84d4659 # commit | 第一次提交.git/objects/56/64e303b5dc2e9ef8e14a0845d9486ec1920afd # blob | README.md.git/objects/6f/b38b7118b554886e96fa736051f18d63a80c85 # blob | 第一次提交 | file.txt.git/objects/a0/e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0 # commit | 第二次提交.git/objects/ae/c2e48cbf0a881d893ccdd9c0d4bbaf011b5b23 # blob | 第二次提交 | file.txt$ tree .git/refs.git/refs├── heads│ └── master└── tags └── v0.0.2 # tag 引用 此时新增了一个 032ddd9 的对象，同时在 .git/refs/ 中增加了名为 v0.0.2 的标签。使用如下命令查看他们的内容： 12345678910111213141516# 查看 v0.0.2 的内容$ cat .git/refs/tags/v0.0.2032ddd9205d65abd773af1610038c764f46a0b12# 查看 032ddd9 的类型$ git cat-file -t 032ddd9tag# 查看 032ddd9 的内容$ git cat-file -p 032ddd9object a0e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0type committag v0.0.2tagger xiaowenxia &lt;775117471@qq.com&gt; 1606913178 +0800this is annotated tag .git/refs/tags/v0.0.2 是 Git 的一个重要的概念：引用。这个引用实际上是一个指针，内容为 032ddd9 的 sha1 值，代表指向 032ddd9 。而 032ddd9 是一个 tag 对象，指向第二次提交的 commit 对象：a0e96b5。 tag 对象相对比较独立，不参与构建文件系统，只是单纯的存储信息。 0xFF 总结到这里其实应该已经对 Git 底层对象有一个深刻的了解了。从根本上来讲，git 底层实际上是由一个个对象（object）组成的，git 底层对象分为4种： blob 对象：保存着文件快照，数据结构参考： blob 对象。 tree 对象：记录着目录结构和 blob 对象索引，其数据结构参考： tree 对象。 commit 对象：包含着指向前述 tree 对象的指针和所有提交信息，数据结构参考：commit 对象。 tag 对象：记录带注释的 tag 。 一个仓库里面的所有 Git 对象会组成一个图（Graph），按照指向关系可以简单的这么理解：refs –&gt; tag 对象 –&gt; commit 对象 –&gt; tree 对象 –&gt; blob 对象，对象之间通过对方的 sha1 值来确定指向关系，所以要是篡改了对象的内容，那指向关系就会被破坏掉，git fsck 命令就会提示 &quot;hash mismatch&quot; 。所以这也是 Git 对象的文件存储结构里面并没有自身数据的校验（checksum）字段的原因。 值得一提的是，git 社区正在积极推进 sha256 的方案，sha1 目前来看并不是绝对安全的，因为 HAttered attack 这种攻击方式能够伪造相同 sha1 值。 最后，我们用一张图来总结上述的一系列步骤生成的对象之间的关系： git 对象的相关命令git 擅长的一点是提供了很多丰富抽象的子命令来操作这些 git 对象，比如上面的一系列操作： git add：实际上是把当前工作区的文件快照保存下来，产出是 blob 对象。 git commit：保存暂存区的文件层级关系和提交者信息，产出是 tree 对象 和 commit 对象。 git tag -m：保存 tag 标签的信息，产出是 tag 对象。 这些是上层命令，实际上 git 还提供了非常丰富的底层命令用来操作对象： git-hash-object：把输入内容存储成 blob 对象。 git-cat-file：读取并格式化输出对象。 git-count-objects：计算对象数量。 git-write-tree：把存储区的文件结构存储成 tree 对象。 git-read-tree：把 tree 对象读取到暂存区。 git-commit-tree：根据输入信息（tree、父提交、author、commiter、日期等）存储成 commit 对象。 git-ls-tree：读取并格式化输出 tree 对象。 git-mktag：把输入内容存储成 tag 对象。 git-mktree：根据输入（ls-tree的输出格式）来生成 tree 对象。 git-fsck：校验对象链表的正确性和有效性。 git-diff-tree：比较 2 个tree 对象 的差异并格式化输出。 设置固定的时间日期、用户名和邮箱本文中的示例都设置了固定的时间日期、用户名和邮箱，如果你是边阅读本文边动手操作，可以如下执行 git commit 或者 git tag ，这样生成的对象hash值和本文中的是一致的： 12345# git commit$ GIT_AUTHOR_DATE=&quot;1606913178 +0800&quot; GIT_AUTHOR_NAME=&quot;xiaowenxia&quot; GIT_AUTHOR_EMAIL=&quot;775117471@qq.com&quot; GIT_COMMITTER_DATE=&quot;1606913178 +0800&quot; GIT_COMMITTER_NAME=&quot;xiaowenxia&quot; GIT_COMMITTER_EMAIL=&quot;775117471@qq.com&quot; git commit -m &quot;first commit&quot;# git tag$ GIT_AUTHOR_DATE=&quot;1606913178 +0800&quot; GIT_AUTHOR_NAME=&quot;xiaowenxia&quot; GIT_AUTHOR_EMAIL=&quot;775117471@qq.com&quot; GIT_COMMITTER_DATE=&quot;1606913178 +0800&quot; GIT_COMMITTER_NAME=&quot;xiaowenxia&quot; GIT_COMMITTER_EMAIL=&quot;775117471@qq.com&quot; git tag &quot;v0.0.2&quot; -m &quot;this is annotated tag&quot; 或者可以使用 export 设置为全局的环境变量： 1export GIT_AUTHOR_DATE=&quot;1606913178 +0800&quot; GIT_AUTHOR_NAME=&quot;xiaowenxia&quot; GIT_AUTHOR_EMAIL=&quot;775117471@qq.com&quot; GIT_COMMITTER_DATE=&quot;1606913178 +0800&quot; GIT_COMMITTER_NAME=&quot;xiaowenxia&quot; GIT_COMMITTER_EMAIL=&quot;775117471@qq.com&quot; 下载本文创建的 git 仓库点击下载本文中创建的仓库。 git-draw这里有一个很有趣的工具：git-draw，这个工具会绘制 git 仓库的所有 Git 对象和引用的关系。下图使用 git-draw 绘制了本文的仓库： 参考资料 https://git-scm.com/book/en/v2/Git-Internals-Git-Objects https://maryrosecook.com/blog/post/git-from-the-inside-out https://matthew-brett.github.io/curious-git/git_object_types.html","categories":[],"tags":[]},{"title":"Git 底层原理：传输协议分析","slug":"git-internal-protocol","date":"2020-11-24T02:28:13.000Z","updated":"2021-02-20T05:24:10.000Z","comments":true,"path":"2020/11/24/git-internal-protocol/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/11/24/git-internal-protocol/","excerpt":"","text":"Git 底层原理：传输协议分析概要Git 客户端和服务端交互的协议支持 4 种：本地协议、HTTP 协议、SSH 协议、 Git 协议，在我们的日常开发过程中，接触最多的是 HTTP 协议和 SSH 协议。一般通过如下命令和服务器进行交互： 123456789# ssh 协议$ git clone ssh://user@server/project.git# 或者$ git clone user@server:project.git# http(s) 协议$ git clone https://server/project.git# 或者带上用户名密码$ git clone https://user:token@server/project.git 参考文章：Git on the Server - The Protocols。 Wireshark 抓包分析 git https 传输协议Wireshark 是一个抓包工具，有非常强大的过滤和分析功能，用该工具分析 git 协议流非常方便。 准备工作本文使用阿里云的代码托管平台 Codeup 来分析传输协议。当然，你也可以使用 Github 或者 Gitee 。 github 使用的是 http/2 协议。 http/2 协议因为数据帧是二进制格式，对于分析 https 交互并不直观，所以本文使用了 Codeup 作为示例，Codeup 使用的是 http/1.1 协议。 1. 查看服务器 ip 地址12host codeup.aliyun.comcodeup.aliyun.com has address 118.31.165.50 服务器 ip 地址为 118.31.165.50 。 2. 设置 SSLKEYLOGFILE 环境变量通过设置 SSLKEYLOGFILE环境变量，可以保存 TLS 的会话钥匙（Session Key），wireshark 再读取 Session Key 然后实时解析 https 数据流，具体可以参考这篇文章：Walkthrough: Decrypt SSL/TLS traffic (HTTPS and HTTP/2) in Wireshark。 1export SSLKEYLOGFILE=~/sslkeylog.log 3. 设置 Wireshark首先让 Wireshark 读取 sslkeylog.log，打开 Wireshark，点击 菜单 &gt;Performances，在对话框中选择 Protocol &gt; TLS，设置 (Pre)-Master-Secret log filename 为你的 SSLKEYLOGFILE 文件路径： 启动wireshark 监听网卡，设置过滤规则为 tls &amp;&amp; http &amp;&amp; ip.addr == 118.31.165.50，其中 118.31.165.50就是获取到的服务器 ip 地址。 git clone做完上面的准备工作后，就可以开始抓包分析了。运行 git clone 命令： 123# 确保设置了 SSLKEYLOGFILE 环境变量# export SSLKEYLOGFILE=~/sslkeylog.log$ git clone https://codeup.aliyun.com/5ed5e6f717b522454a36976e/Codeup-Demo.git Wireshark 抓包得到如下数据包： 点击 菜单 &gt; Analyze &gt; Follow &gt; HTTP Stream 可以更直观的查看数据交互流： 接下来分析一下 git clone 的交互过程。 第一次交互：引用发现第一次交互主要起到 握手 + 获取仓库信息 的作用。服务端认证用户信息，并告诉客户端对应仓库的所有引用信息，以及相关的仓库信息。 123456789101112131415161718192021首先客户端发起请求（在&#96;Authorization&#96;字段附上了用户名密码）&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;GET &#x2F;5ed5e6f717b522454a36976e&#x2F;Codeup-Demo.git&#x2F;info&#x2F;refs?service&#x3D;git-upload-pack&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务端认证用户信息，然后返回引用列表&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;001e# service&#x3D;git-upload-pack000001163ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 HEAD\\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow deepen-since deepen-not deepen-relative no-progress include-tag multi_ack_detailed no-done symref&#x3D;HEAD:refs&#x2F;heads&#x2F;master object-format&#x3D;sha1 agent&#x3D;git&#x2F;2.28.0.agit.6.00040f82d3c440cf02ff2e20d712eaa7ba63a9fbff4ea refs&#x2F;heads&#x2F;develop004961ee902744d1f5a480e607856d44b104602d6b13 refs&#x2F;heads&#x2F;feature&#x2F;p3c_scan004fae02248d14bfdc9d4d38b1532cab278d179bc863 refs&#x2F;heads&#x2F;feature&#x2F;sensitive_scan003f3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs&#x2F;heads&#x2F;master00676508471ba8d143e1bfc41c391280a7ef533be57b refs&#x2F;keep-around&#x2F;6508471ba8d143e1bfc41c391280a7ef533be57b0067fe94112642bb8c57f6d08309f376135744fcb24e refs&#x2F;keep-around&#x2F;fe94112642bb8c57f6d08309f376135744fcb24e004d6508471ba8d143e1bfc41c391280a7ef533be57b refs&#x2F;merge-requests&#x2F;267112&#x2F;head004dfe94112642bb8c57f6d08309f376135744fcb24e refs&#x2F;merge-requests&#x2F;267123&#x2F;head003c3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs&#x2F;tags&#x2F;v1.00000&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 服务端返回的信息具有一定的格式（ pkt-line 格式 ），每一行都以一个四位的十六进制值开始，用于指明本行的长度。第二行的 0000 和结尾 0000 告诉 git 已经完成了一个过程。 这次交互里面，根据 0000 出现的位置，可以知道服务端返回的信息里面包含了2部分，第一部分是： 12001e# service&#x3D;git-upload-pack0000 表示这次回复的数据类型是 git-upload-pack。 第二部分的第一行内容信息比较多： 101163ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 HEAD\\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow deepen-since deepen-not deepen-relative no-progress include-tag multi_ack_detailed no-done symref&#x3D;HEAD:refs&#x2F;heads&#x2F;master object-format&#x3D;sha1 agent&#x3D;git&#x2F;2.28.0.agit.6.0 这段信息主要描述 HEAD 指针信息，以及功能列表信息，比如 symref=HEAD:refs/heads/master 表示默认分支为 master ，object-format=sha1 表示对象使用 sha1 校验对象，agent=git/2.28.0.agit.6.0 服务器 git 版本信息。 第二部分第二行开始的信息则是 info/refs 文件内容。info/refs 文件描述了仓库里面的引用信息，包括分支、 tag ，以及一些自定义引用等。 值得一提的是，服务器回复的 info/refs 文件内容里，除了 refs/heads/* 和 refs/tags/*，还存在 refs/keep-around/* 和 refs/merge-requests/* 等引用，这些是 Codeup 平台特有的引用。 你也可以使用 `git --exec-path`/git-update-server-info 命令来生成 info/refs 文件： 12345678$ `git --exec-path`/git-update-server-info &amp;&amp; cat .git/info/refs3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/heads/master3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/remotes/origin/HEADf82d3c440cf02ff2e20d712eaa7ba63a9fbff4ea refs/remotes/origin/develop61ee902744d1f5a480e607856d44b104602d6b13 refs/remotes/origin/feature/p3c_scanae02248d14bfdc9d4d38b1532cab278d179bc863 refs/remotes/origin/feature/sensitive_scan3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/remotes/origin/master3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/tags/v1.0 实际上这一段的数据流及格式官方文档里面有详细的说明： http-protocol.txt，也可以参考本文末的 git 传输协议格式。 第二次交互：请求数据第二次交互里，客户端把想要的数据告诉给服务端，服务端然后把 pack 包推送回来。 123456789101112131415161718192021222324252627282930客户端发送数据到服务器&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;POST &#x2F;5ed5e6f717b522454a36976e&#x2F;Codeup-Demo.git&#x2F;git-upload-pack00a8want f82d3c440cf02ff2e20d712eaa7ba63a9fbff4ea multi_ack_detailed no-done side-band-64k thin-pack ofs-delta deepen-since deepen-not agent&#x3D;git&#x2F;2.24.3.(Apple.Git-128)0032want 61ee902744d1f5a480e607856d44b104602d6b130032want ae02248d14bfdc9d4d38b1532cab278d179bc8630032want 3ab7c8d1c1e2ce5f5e16a17c41f6665686980d120032want 3ab7c8d1c1e2ce5f5e16a17c41f6665686980d1200000009done&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务器回复 pack 包&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;0008NAK0024\\0x02Enumerating objects: 48, done.0023.Counting objects: 2% (1&#x2F;48)0023.Counting objects: 4% (2&#x2F;48)...省略...0024.Counting objects: 97% (47&#x2F;48)0024.Counting objects: 100% (48&#x2F;48)002b.Counting objects: 100% (48&#x2F;48), done.2004.PACK.......0..x...... ....O.&#125;!81.KY..OQ.q.)....&#125;..C...&gt;..Et,.&quot;..)........O.b :o..2G...uhK.s.. 3.+N. &lt;&#x2F;P..a..L.Y.1...k.r..71..........X...X.......m.B&#123;Z....m.hp......2..u.&#125;.C&gt;&#x2F;+.Y.j..k...m.&gt;&#x3D;.M....Z...x...Aj.!.....&#123;.&#96;....B&#96;...m...2.....G.Z..Z.........E.O&amp;D&quot;g.V....省略.........,.....$.....x.&#125;Q&#x3D;k.1...+.MI...,.Ph.PH...OM..,W..A...&#125;M..J5........&#123;.Em....9...a...T.A..G.+..H,.x.)...w6&#x3D;......I..ay.....7.q......G....1...X.G..s0&#39;H....;..O%.....&quot;.....:......d1V....fJ...d....pd..j1JV1o...z..~C_l......%...N..z.L....@.+.V+&#39;...|.&#x3D;..c:&amp;&#125;&#39;..T....r~...9F+.......7....V(s3....uQ....T7.&#x3D;F..Gt&#96;i.Z. n..Vn0006..003b.Total 48 (delta 0), reused 0 (delta 0), pack-reused 00000&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 通过第一次交互里，客户端拿到了远程仓库的引用列表，然后把想要的 commit-id （及其提交链）发送给服务端。具体点其实就是 branch 和 tag 对应的 commit-id 。数据格式跟上面的服务端回复的引用列表格式类似。 服务器回复的是 HTTP 数据流格式，其中包括了进度、pack 二进制数据等，其第一行的 NAK 代表数据开始， git 传输协议格式pkt-line 数据流pkt-line 数据流用来描述引用信息，每一行的前四个字节代表这一行的十六进制编码的长度，包括这四个字节和数据在内。因为包括自身四个字节，前四个直接一定大于0004，所以 pkt-line 格式定义了3个特殊的编码： 0000 ( flush-pkt )：代表一段消息的结束。 0001 ( delim-pkt )：代表一段消息的分节符。 0002 ( response-end-pkt )：无状态会话时响应结束。 整体来讲，一个 pkt-line 数据流一般由如下几部分组成： 1234PKT-LINE(&quot;# service&#x3D;$servicename&quot; LF)&quot;0000&quot;ref_list&quot;0000&quot; 其中 PKT-LINE 代表这一行是 pkt-line 格式的。 servicename 是服务类型，git clone、git fetch 时是 git-upload-pack，git push 则是 git-receive-pack。 ref_list 是引用信息列表，一定是按照引用名称排序的。 ref_list 第一个引用一定是 HEAD ， HEAD 后面一定有支持的功能说明（ capability declarations ）第一条引用信息格式为： 1PKT-LINE(obj-id SP name NUL cap_list LF) cap_list 是支持的功能列表。后面的引用信息格式为： 12345PKT-LINE(obj-id SP name LF)# 或者PKT-LINE(obj-id SP name LF)PKT-LINE(obj-id SP name &quot;^&#123;&#125;&quot; LF) 其中 name^&#123;&#125; 是 git revision 中定义的格式，表示递归该引用找到非 tag 类型的 object 。另外，如果该仓库没有引用时，那 ref_list 的内容则是：PKT-LINE(zero-id SP &quot;capabilities^&#123;&#125;&quot; NUL cap-list LF) 。 pkt-line 官方说明见：http-protocol.txt。 sideband 格式前四个字节和 pkt-line 格式相同，代表这一行的数据长度。第五位用于标志消息类型，0x01 代表是packfile 数据，0x02 代表是进度消息，0x03 代表是错误信息。 如下绘制了git clone 的 https 协议交互图： git fetchgit push分析 git ssh 传输协议git clonegit fetchgit pushwireshark 过滤条件tls &amp;&amp; ip.addr == 118.31.165.50 http(s)://，ssh://，git:// 1234567891011121314151617181920HTTP&#x2F;1.1 200 OKServer: TengineDate: Thu, 18 Feb 2021 12:48:44 GMTContent-Type: application&#x2F;x-git-upload-pack-advertisementContent-Length: 1015Connection: keep-aliveCache-Control: no-cache001e# service&#x3D;git-upload-pack000001163ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 HEADmulti_ack thin-pack side-band side-band-64k ofs-delta shallow deepen-since deepen-not deepen-relative no-progress include-tag multi_ack_detailed no-done symref&#x3D;HEAD:refs&#x2F;heads&#x2F;master object-format&#x3D;sha1 agent&#x3D;git&#x2F;2.28.0.agit.6.00040f82d3c440cf02ff2e20d712eaa7ba63a9fbff4ea refs&#x2F;heads&#x2F;develop004961ee902744d1f5a480e607856d44b104602d6b13 refs&#x2F;heads&#x2F;feature&#x2F;p3c_scan004fae02248d14bfdc9d4d38b1532cab278d179bc863 refs&#x2F;heads&#x2F;feature&#x2F;sensitive_scan003f3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs&#x2F;heads&#x2F;master00676508471ba8d143e1bfc41c391280a7ef533be57b refs&#x2F;keep-around&#x2F;6508471ba8d143e1bfc41c391280a7ef533be57b0067fe94112642bb8c57f6d08309f376135744fcb24e refs&#x2F;keep-around&#x2F;fe94112642bb8c57f6d08309f376135744fcb24e004d6508471ba8d143e1bfc41c391280a7ef533be57b refs&#x2F;merge-requests&#x2F;267112&#x2F;head004dfe94112642bb8c57f6d08309f376135744fcb24e refs&#x2F;merge-requests&#x2F;267123&#x2F;head003c3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs&#x2F;tags&#x2F;v1.00000 123456700a8want f82d3c440cf02ff2e20d712eaa7ba63a9fbff4ea multi_ack_detailed no-done side-band-64k thin-pack ofs-delta deepen-since deepen-not agent&#x3D;git&#x2F;2.24.3.(Apple.Git-128)0032want 61ee902744d1f5a480e607856d44b104602d6b130032want ae02248d14bfdc9d4d38b1532cab278d179bc8630032want 3ab7c8d1c1e2ce5f5e16a17c41f6665686980d120032want 3ab7c8d1c1e2ce5f5e16a17c41f6665686980d1200000009done ssh 是建立在tcp之上的。最后协商成功之后，将会生成一个对称加密 会话密钥key 以及一个 会话ID ，在这里要特别强调，这个是对称加密密钥key， 从服务器拉取 拉取 info/refs 文件内容。 12345678`git --exec-path`/git-update-server-info &amp;&amp; cat .git/info/refs3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/heads/master3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/remotes/origin/HEADf82d3c440cf02ff2e20d712eaa7ba63a9fbff4ea refs/remotes/origin/develop61ee902744d1f5a480e607856d44b104602d6b13 refs/remotes/origin/feature/p3c_scanae02248d14bfdc9d4d38b1532cab278d179bc863 refs/remotes/origin/feature/sensitive_scan3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/remotes/origin/master3ab7c8d1c1e2ce5f5e16a17c41f6665686980d12 refs/tags/v1.0 上面使用wireshark 抓取到的协议叫智能（smart）协议，实际上 Git 1.6.6 之前的版本（2010年前）一直使用哑(Dumb)协议。使用哑协议的版本库很难保证安全性和私有化，而且只能架设只读版本库，目前已经很少使用了，哑协议的交互过程可以参考《Git Internals - Transfer Protocols》。 参考资料 https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols https://git-scm.com/book/en/v2/Git-Internals-Transfer-Protocols https://wangdoc.com/ssh/client.html https://github.com/gcla/termshark https://github.com/git/git/blob/master/Documentation/technical/http-protocol.txt","categories":[],"tags":[]},{"title":"Git 常用命令底层原理","slug":"git-internal-operations","date":"2020-11-24T02:28:13.000Z","updated":"2021-02-16T08:42:24.000Z","comments":true,"path":"2020/11/24/git-internal-operations/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/11/24/git-internal-operations/","excerpt":"","text":"Git 常用命令底层原理git clone 具体干了些啥？git push 具体干了些啥？git log从 HEAD 开始显示历史的提交。 git status当前工作目录和 HEAD 做对比 git diff显示当前工作目录和 HEAD 的文件差异，--cached 选项用来比较暂存区的文件 和 HEAD指向的文件。 git mv 和 git rm移动或者删除文件，该操作和 git add 类似。","categories":[],"tags":[]},{"title":"Git 引用","slug":"git-refs","date":"2020-11-02T07:09:43.000Z","updated":"2021-02-16T07:00:09.000Z","comments":true,"path":"2020/11/02/git-refs/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/11/02/git-refs/","excerpt":"","text":"Git 引用Git 引用本质上是指向特定的 commit 对象，git 默认情况下都会有一个 master 引用，指向一个默认的分支。 github 上已经把默认的分支从 master 改成了 main 分支。 Git 还存在一个 HEAD 引用，代表当前工作的 tree。 1234567891011$ tree .git&#x2F;refs.git&#x2F;refs├── heads│ └── master├── merge-requests│ └── 267123│ └── head├── remotes│ └── origin│ └── HEAD└── tags headsmerge-requests gerrit remotes tags HEADHEAD是一个指针，指向当前的操作分支。 使用 cat .git/HEAD 命令可以查看 HEAD 内容： 12$ cat .git/HEADref: refs/heads/main HEAD有很多方便的用法，比如： 1234# 查看当前分支的日志$ git log HEAD# 恢复上一次提交到工作区$ git reset HEAD^ 同时，HEAD 作为 revisions 时，也有很多奇妙的用法，比如 HEAD^ 代表上一次提交、HEAD~6 代表往回追溯6个版本的那个提交等。 FETCH_HEAD存储每个分支最后一次和服务器通信的最后的 commit-idORIG_HEAD同步当前分支和远程分支的最后的 commit-idCOMMIT_EDITMSG最后一次 commit 时的注释 git describe 参考：https://git-scm.com/docs/git-describe git 的 describe 命令是用来给一个 refs 添加方面阅读的描述信息，git-describe - Give an object a human readable name based on an available ref","categories":[],"tags":[]},{"title":"Git 的分支策略","slug":"git-branch","date":"2020-10-26T06:09:09.000Z","updated":"2021-02-16T04:45:10.000Z","comments":true,"path":"2020/10/26/git-branch/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/26/git-branch/","excerpt":"","text":"Git 的分支策略git 的一些分支命令，具体做了哪些事情？git checkoutgit branch -bgit taggit rebasegit pull/pushgit fetchgit resetgit stash","categories":[],"tags":[]},{"title":"Git 术语","slug":"git-glossary","date":"2020-10-25T14:50:02.000Z","updated":"2021-02-16T08:42:24.000Z","comments":true,"path":"2020/10/25/git-glossary/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/25/git-glossary/","excerpt":"","text":"Git 术语 翻译自 Git Glossary。 alternate object databaseVia the alternates mechanism, a repository can inherit part of its object database from another object database, which is called an “alternate”. bare repository空仓库，刚初始化完的仓库。 blob object数据对象，存储当前版本下的文件内容。 branch分支，代表当前时间线的开发代码。 cachegit 初期的叫法，现在叫索引（index）。 chaincommit 链，这些链则组成一个个分支。 changesetBitKeeper/cvsps 对 提交（commit）的叫法。 checkout从 git 文件系统中检出对应的版本或文件到工作目录，如果检出的是分支则会更新索引（index）和 HEAD。 cherry-picking提取某些 commit 到当前分支。 clean清理当前工作区。 commit提交。 commit object一次提交会生成一份 commit 对象，该对象包括committer、 author、date、 tree-id 等信息。 commit-ish (also committish)A commit object or an object that can be recursively dereferenced to a commit object. The following are all commit-ishes: a commit object, a tag object that points to a commit object, a tag object that points to a tag object that points to a commit object, etc. core Gitgit 底层的数据结构和对象，以及很丰富的底层命令。 DAGDirected acyclic graph. The commit objects form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no chain which begins and ends with the same object). dangling objectAn unreachable object which is not reachable even from other unreachable objects; a dangling object has no references to it from any reference or object in the repository. detached HEADNormally the HEAD stores the name of a branch, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to check out an arbitrary commit that isn’t necessarily the tip of any particular branch. The HEAD in such a state is called “detached”. Note that commands that operate on the history of the current branch (e.g. git commit to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information about the current branch (e.g. git branch –set-upstream-to that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state. directory目录。 dirty工作区有改动没有提交，该工作区则为 dirty 状态。 evil mergeAn evil merge is a merge that introduces changes that do not appear in any parent. fast-forwardA fast-forward is a special type of merge where you have a revision and you are “merging” another branch’s changes that happen to be a descendant of what you have. In such a case, you do not make a new merge commit but instead just update to his revision. This will happen frequently on a remote-tracking branch of a remote repository. fetch从远程仓库拉取最新分支。 file systemLinus Torvalds 一开始设计 Git 的时候，定位就是一个用户空间的文件系统，然后提供高效的命令和方法用于操作这个文件系统。 Git archive对于一些人来讲，这是 repository 的同义词。 gitfile.git 是一个工作区根目录的空文件，指向真正仓库的目录。 graftsGrafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of parents a commit has is different from what was recorded when the commit was created. Configured via the .git/info/grafts file. Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see git-replace[1] for a more flexible and robust system to do the same thing. hashGit 的对象名称都是对象内容的 hash 值。 head指向分支的最新提交。 HEAD指向当前分支。 head refhead 的别名。 hookgit 钩子。 index索引文件。 index entryThe information regarding a particular file, stored in the index. An index entry can be unmerged, if a merge was started, but not yet finished (i.e. if the index contains multiple versions of that file). mastergit 默认的分支。git 仓库初始化时默认会创建该分支。 mergeAs a verb: To bring the contents of another branch (possibly from an external repository) into the current branch. In the case where the merged-in branch is from a different repository, this is done by first fetching the remote branch and then merging the result into the current branch. This combination of fetch and merge operations is called a pull. Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together. In cases where changes conflict, manual intervention may be required to complete the merge. As a noun: unless it is a fast-forward, a successful merge results in the creation of a new commit representing the result of the merge, and having as parents the tips of the merged branches. This commit is referred to as a “merge commit”, or sometimes just a “merge”. objectgit 的 存储单元，git 的底层文件系统都是一个个对象，包括 blob 对象、tree 对象、commit 对象、tag 对象等。 object database存储一组对象。 object identifier和 object name 一样。 object name对象的名称即对象的 hash 值。 object type对象类型，分别有 “commit”, “tree”, “tag”, “blob”。 octopusmerge 超过 2 个分支。 origin上游默认仓库。 overlayOnly update and add files to the working directory, but don’t delete them, similar to how cp -R would update the contents in the destination directory. This is the default mode in a checkout when checking out files from the index or a tree-ish. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to rsync –delete. pack用于压缩存储一组对象。 pack index压缩存储一组对象时，使用 pack index 存储对象的索引和信息。 pathspecPattern used to limit paths in Git commands. Pathspecs are used on the command line of “git ls-files”, “git ls-tree”, “git add”, “git grep”, “git diff”, “git checkout”, and many other commands to limit the scope of operations to some subset of the tree or worktree. See the documentation of each command for whether paths are relative to the current directory or toplevel. The pathspec syntax is as follows: any path matches itself the pathspec up to the last slash represents a directory prefix. The scope of that pathspec is limited to that subtree. the rest of the pathspec is a pattern for the remainder of the pathname. Paths relative to the directory prefix will be matched against that pattern using fnmatch(3); in particular, * and ? can match directory separators. For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg. A pathspec that begins with a colon : has special meaning. In the short form, the leading colon : is followed by zero or more “magic signature” letters (which optionally is terminated by another colon :), and the remainder is the pattern to match against the path. The “magic signature” consists of ASCII symbols that are neither alphanumeric, glob, regex special characters nor colon. The optional colon that terminates the “magic signature” can be omitted if the pattern begins with a character that does not belong to “magic signature” symbol set and is not a colon. In the long form, the leading colon : is followed by an open parenthesis (, a comma-separated list of zero or more “magic words”, and a close parentheses ), and the remainder is the pattern to match against the path. A pathspec with only a colon means “there is no pathspec”. This form should not be combined with other pathspec. topThe magic word top (magic signature: /) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory. literalWildcards in the pattern such as * or ? are treated as literal characters. icaseCase insensitive match. globGit treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname. For example, “Documentation/*.html” matches “Documentation/git.html” but not “Documentation/ppc/ppc.html” or “tools/perf/Documentation/perf.html”. Two consecutive asterisks (“**”) in patterns matched against full pathname may have special meaning: A leading ““ followed by a slash means match in all directories. For example, “/foo” matches file or directory “foo” anywhere, the same as pattern “foo”. “**/foo/bar” matches file or directory “bar” anywhere that is directly under directory “foo”. A trailing “/“ matches everything inside. For example, “abc/“ matches all files inside directory “abc”, relative to the location of the .gitignore file, with infinite depth. A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, “a/**/b” matches “a/b”, “a/x/b”, “a/x/y/b” and so on. Other consecutive asterisks are considered invalid. Glob magic is incompatible with literal magic. attrAfter attr: comes a space separated list of “attribute requirements”, all of which must be met in order for the path to be considered a match; this is in addition to the usual non-magic pathspec pattern matching. See gitattributes[5]. Each of the attribute requirements for the path takes one of these forms: “ATTR” requires that the attribute ATTR be set. “-ATTR” requires that the attribute ATTR be unset. “ATTR=VALUE” requires that the attribute ATTR be set to the string VALUE. “!ATTR” requires that the attribute ATTR be unspecified. Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object. excludeAfter a path matches any non-exclude pathspec, it will be run through all exclude pathspecs (magic signature: ! or its synonym ^). If it matches, the path is ignored. When there is no non-exclude pathspec, the exclusion is applied to the result set as if invoked without any pathspec. parentA commit object contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents. pickaxeThe term pickaxe refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the –pickaxe-all option, it can be used to view the full changeset that introduced or removed, say, a particular line of text. See git-diff[1]. plumbingcore Git 的别名。 porcelainCute name for programs and program suites depending on core Git, presenting a high level access to core Git. Porcelains expose more of a SCM interface than the plumbing. per-worktree refRefs that are per-worktree, rather than global. This is presently only HEAD and any refs that start with refs/bisect/, but might later include other unusual refs. pseudorefPseudorefs are a class of files under $GIT_DIR which behave like refs for the purposes of rev-parse, but which are treated specially by git. Pseudorefs both have names that are all-caps, and always start with a line consisting of a SHA-1 followed by whitespace. So, HEAD is not a pseudoref, because it is sometimes a symbolic ref. They might optionally contain some additional data. MERGE_HEAD and CHERRY_PICK_HEAD are examples. Unlike per-worktree refs, these files cannot be symbolic refs, and never have reflogs. They also cannot be updated through the normal ref update machinery. Instead, they are updated by directly writing to the files. However, they can be read as if they were refs, so git rev-parse MERGE_HEAD will work. pullpull 分支时，会先拉取（fetch）然后再覆盖（merge）。 push把当前的本地仓库版本提交到远程仓库。 reachableAll of the ancestors of a given commit are said to be “reachable” from that commit. More generally, one object is reachable from another if we can reach the one from the other by a chain that follows tags to whatever they tag, commits to their parents or trees, and trees to the trees or blobs that they contain. rebaseTo reapply a series of changes from a branch to a different base, and reset the head of that branch to the result. refA name that begins with refs/ (e.g. refs/heads/master) that points to an object name or another ref (the latter is called a symbolic ref). For convenience, a ref can sometimes be abbreviated when used as an argument to a Git command; see gitrevisions[7] for details. Refs are stored in the repository. The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the refs/heads/ hierarchy is used to represent local branches). There are a few special-purpose refs that do not begin with refs/. The most notable example is HEAD. reflog显示 ref 的变更日志。 refspecA “refspec” is used by fetch and push to describe the mapping between remote ref and local ref. remote repository远程仓库。 remote-tracking branchA ref that is used to follow changes from another repository. It typically looks like refs/remotes/foo/bar (indicating that it tracks a branch named bar in a remote named foo), and matches the right-hand-side of a configured fetch refspec. A remote-tracking branch should not contain direct modifications or have local commits made to it. repository代码仓库。 resolveThe action of fixing up manually what a failed automatic merge left behind. revision用于定位版本。 rewindTo throw away part of the development, i.e. to assign the head to an earlier revision. SCM源码管理工具。 SHA-1git 默认使用 SHA-1 来对对象或内容做hash运算。 shallow cloneMostly a synonym to shallow repository but the phrase makes it more explicit that it was created by running git clone –depth=… command. shallow repositoryA shallow repository has an incomplete history some of whose commits have parents cauterized away (in other words, Git is told to pretend that these commits do not have the parents, even though they are recorded in the commit object). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the –depth option to git-clone[1], and its history can be later deepened with git-fetch[1]. stash entryAn object used to temporarily store the contents of a dirty working directory and the index for future reuse. submodule子仓库，可以用来做多仓库集成。 superprojectA repository that references repositories of other projects in its working tree as submodules. The superproject knows about the names of (but does not hold copies of) commit objects of the contained submodules. symrefSymbolic reference: instead of containing the SHA-1 id itself, it is of the format ref: refs/some/thing and when referenced, it recursively dereferences to this reference. HEAD is a prime example of a symref. Symbolic references are manipulated with the git-symbolic-ref[1] command. tagA ref under refs/tags/ namespace that points to an object of an arbitrary type (typically a tag points to either a tag or a commit object). In contrast to a head, a tag is not updated by the commit command. A Git tag has nothing to do with a Lisp tag (which would be called an object type in Git’s context). A tag is most typically used to mark a particular point in the commit ancestry chain. tag objectAn object containing a ref pointing to another object, which can contain a message just like a commit object. It can also contain a (PGP) signature, in which case it is called a “signed tag object”. topic branchA regular Git branch that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes. tree工作树（working tree）或tree对象。 tree objecttree 对象，存储一组blob对象，相当于存储目录。 tree-ish (also treeish)A tree object or an object that can be recursively dereferenced to a tree object. Dereferencing a commit object yields the tree object corresponding to the revision’s top directory. The following are all tree-ishes: a commit-ish, a tree object, a tag object that points to a tree object, a tag object that points to a tag object that points to a tree object, etc. unmerged indexAn index which contains unmerged index entries. unreachable objectAn object which is not reachable from a branch, tag, or any other reference. upstream branchThe default branch that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch..remote and branch..merge. If the upstream branch of A is origin/B sometimes we say “A is tracking origin/B”. working tree工作区。","categories":[],"tags":[]},{"title":"Git 的一些环境变量","slug":"git-env","date":"2020-10-25T12:10:37.000Z","updated":"2021-02-16T08:42:24.000Z","comments":true,"path":"2020/10/25/git-env/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/25/git-env/","excerpt":"","text":"Git 的一些环境变量 参考：https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F 和 https://git-scm.com/docs/git#_environment_variables 。 GIT_TRACEGIT_TRACE=1 可以显示具体的git内部执行过程，比如： 12345678910111213141516171819202122232425262728# 查看 git pull 的执行过程$ GIT_TRACE=1 git pull10:15:16.423653 git.c:344 trace: built-in: git pull10:15:16.424388 run-command.c:646 trace: run_command: git fetch --update-head-ok10:15:16.425853 git.c:344 trace: built-in: git fetch --update-head-ok10:15:16.426444 run-command.c:646 trace: run_command: unset GIT_DIR GIT_PREFIX; ssh git@gitlab.alibaba-inc.com &#x27;git-upload-pack &#x27;&#x27;&#x27;agit/galileo.git&#x27;&#x27;&#x27;&#x27;10:15:16.883780 run-command.c:646 trace: run_command: git rev-list --objects --stdin --not --all --quiet10:15:16.886473 run-command.c:646 trace: run_command: git rev-list --objects --stdin --not --all --quiet10:15:16.888001 git.c:344 trace: built-in: git rev-list --objects --stdin --not --all --quiet10:15:16.926434 run-command.c:1569 run_processes_parallel: preparing to run up to 1 tasks10:15:16.926536 run-command.c:1601 run_processes_parallel: done10:15:16.926622 run-command.c:646 trace: run_command: git gc --auto10:15:16.928214 git.c:344 trace: built-in: git gc --auto10:15:16.929016 run-command.c:646 trace: run_command: git merge FETCH_HEAD10:15:16.930404 git.c:344 trace: built-in: git merge FETCH_HEAD# 查看 git status 的执行过程$ GIT_TRACE=1 git st10:18:16.275652 git.c:576 trace: exec: git-st10:18:16.275723 run-command.c:646 trace: run_command: git-st10:18:16.275835 git.c:274 trace: alias expansion: st =&gt; status10:18:16.275870 git.c:576 trace: exec: git-status10:18:16.275876 run-command.c:646 trace: run_command: git-status10:18:16.277339 git.c:344 trace: built-in: git statusOn branch masterYour branch is up to date with &#x27;origin/master&#x27;.nothing to commit, working tree clean GIT_DIRGIT_CURL_VERBOSEGIT_TRACE_PACKETGIT_TERMINAL_PROMPTGIT_AUTHOR_DATEGIT_AUTHOR_NAMEGIT_AUTHOR_EMAILGIT_COMMITTER_DATEGIT_COMMITTER_NAMEGIT_COMMITTER_EMAIL","categories":[],"tags":[]},{"title":"Git 的配置说明","slug":"git-config","date":"2020-10-21T08:29:22.000Z","updated":"2021-02-16T08:42:24.000Z","comments":true,"path":"2020/10/21/git-config/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/21/git-config/","excerpt":"","text":"Git 的配置说明 参考 Pro Git 的 Customizing Git - Git Configuration。更详细的配置项说明见：https://git-scm.com/docs/git-config 。 git 的 3 种配置git 有 3 种配置，分别为当前工作区配置、全局配置、系统配置，各自的配置文件分别为： 当前工作区配置文件：&lt;repo&gt;/.git/config。 全局配置文件：~/.gitconfig。 系统配置文件：/etc/gitconfig。 git config 命令，分别可以使用 --local 、 --global 、 --system 来设置对应的git 配置： 12345678# 查看当前工作区配置$ git config --local --list# 查看全局配置$ git config --global --list# 查看系统配置$ git config --system --list# 查看当前生效的配置$ git config --list 常见的配置项12345678# 配置用户名$ git config --global user.name &quot;xiaowenxia&quot;# 配置邮箱$ git config --global user.email &quot;775117471@qq.com&quot;# 配置自动颜色$ git config --global color.ui auto# 配置默认的编辑器为vim$ git config --global core.editor vim git config 命令说明（点击展开） usage: git config [&lt;options&gt;] Config file location --global use global config file --system use system config file --local use repository config file --worktree use per-worktree config file -f, --file &lt;file&gt; use given config file --blob &lt;blob-id&gt; read config from given blob object Action --get get value: name [value-regex] --get-all get all values: key [value-regex] --get-regexp get values for regexp: name-regex [value-regex] --get-urlmatch get value specific for the URL: section[.var] URL --replace-all replace all matching variables: name value [value_regex] --add add a new variable: name value --unset remove a variable: name [value-regex] --unset-all remove all matches: name [value-regex] --rename-section rename section: old-name new-name --remove-section remove a section: name -l, --list list all -e, --edit open an editor --get-color find the color configured: slot [default] --get-colorbool find the color setting: slot [stdout-is-tty] Type -t, --type &lt;&gt; value is given this type --bool value is &quot;true&quot; or &quot;false&quot; --int value is decimal number --bool-or-int value is --bool or --int --path value is a path (file or directory name) --expiry-date value is an expiry date Other -z, --null terminate values with NUL byte --name-only show variable names only --includes respect include directives on lookup --show-origin show origin of config (file, standard input, blob, command line) --default &lt;value&gt; with --get, use default value when missing entry 更多配置项core.editorgit 默认使用环境变量 VISUAL 或 EDITOR 作为默认的编辑器，用户可以通过配置 core.editor 设置默认的编辑器。 commit.templatecommit.template 可以让你配置 git commit 时的提交信息的模板文件： 1234# 配置 commit 模板文件为 ~/.gitmessage.txt$ git config --global commit.template ~/.gitmessage.txt# 提交时，则会显示模板$ git commit core.pager配置默认的查看git 输出的工具，比如 git log、 git diff等，默认为 less，当然你也可以配置成其他的翻页工具： 1234# 配置成 more$ git config --global core.pager more# 配置为空，则不使用翻页工具$ git config --global core.pager &#x27;&#x27; user.signingkey设置你的 GPG 签名id： 1$ git config --global user.signingkey &lt;gpg-key-id&gt; core.excludesfile设置全局 ignore 的文件，该配置项相当于全局的 .gitignore 文件。 1$ git config --global core.excludesfile ~/.gitignore_global help.autocorrectgit 命令如果输入有误时，会提示是否存在类似的命令，比如： 123456# 故意输错 chekcout，则提示相似的 checkout 命令$ git chekcout mastergit: &#x27;chekcout&#x27; is not a git command. See &#x27;git --help&#x27;.The most similar command is checkout help.autocorrect 则可以让 git 自动纠正命令并执行： 1234$ git chekcout masterWARNING: You called a Git command named &#x27;chekcout&#x27;, which does not exist.Continuing under the assumption that you meant &#x27;checkout&#x27;in 0.1 seconds automatically... color.ui设置 git 命令输出是否带有颜色。git 还支持更细颗粒度的颜色输出配置： 1234color.branchcolor.diffcolor.interactivecolor.status core.autocrlfWindows 和 Linux/MacOS 的换行符是有差异的，Windows的换行符是 CRLF，Linux/MacOS 的换行符是LF，如果用户在 Windows 上提交代码，那 checkout 到Linux/MacOS 平台上则会有显示问题，开启 core.autocrlf 配置项则可以让 git 根据平台自动转换换行符。 1$ git config --global core.autocrlf true core.attributesFile设置 .gitattributes 文件路径。 配置 merge 或者 diff 工具git 还支持配置 merge 或者 diff 工具，比如如下的配置： 12345$ git config --global merge.tool extMerge$ git config --global mergetool.extMerge.cmd \\ &#x27;extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;&#x27;$ git config --global mergetool.extMerge.trustExitCode false$ git config --global diff.external extDiff 详细配置说明请参考 Customizing Git - Git Configuration。","categories":[],"tags":[]},{"title":"Git 的特殊文件","slug":"git-internal-files","date":"2020-10-20T03:06:40.000Z","updated":"2021-02-17T05:52:40.000Z","comments":true,"path":"2020/10/20/git-internal-files/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/20/git-internal-files/","excerpt":"","text":"Git 的特殊文件.gitignore配置忽略的文件或目录 .gitattribute 参考官方手册：https://git-scm.com/docs/gitattributes .gitattribute 可以为每个目录定义想要的属性，同时也支持匹配方式来设定一组目录。一个简单的示例： 12345678910a* foo !bar -baz(in .gitattributes)abc foo bar baz(in t/.gitattributes)ab* merge=filfreabc -foo -bar*.c frotz gitattributes 文件存储路径 仓库 $GIT_DIR/info/attributes 根目录 子目录 用户全局路径：$HOME/.config/git/gitattributes 也可以通过配置项 core.attributesFile 配置文件路径，参考 git-config。 系统路径：/etc/gitattributes 定义 gitattributes ，除了 .gitattribute 文件，也可以是 $GIT_DIR/info/attributes。 .gitattribute 格式非常简单，每一行定义一个或一组属性，中间使用空格作为分隔符： 12pattern attr1 attr2 ...pattern2 attr1 attr2 ... 开头、结尾的空格都会忽略，(#)开头的行也会被忽略，双引号(&quot;)开头的 pattern 使用 C 语言风格。后一行的属性会覆盖前面的属性。 每个路径的属性都有如下状态： Set 设置属性为 true。 Unset 设置该属性为 false。 设置成某个值 Unspecifiedgitattributes 支持的属性有： 路径的匹配规则和.gitignore几乎是一样的。 .gitattribute 的优先级.gitattribute 的优先级由高到低分别是： $GIT_DIR/info/attributes 路径下的 .gitattribute 上级目录下的 .gitattribute 更上级目录的.gitattribute 根目录下的 .gitattribute 全局的.gitattribute 系统的.gitattribute 比如存在如下文件： 123456789101112131415161718# 系统/etc/gitattributes #1# 全局/User/xxx/.gitattributes #2# 本地仓库├── .git| ├── ......│ ├── info│ │ └── .gitattributes #3| └── ......├── .gitattributes #4├── ......└── subdir ├── .gitattributes #5 └── subdirx └── .gitattributes #6 那优先级分别是 #3 &gt; #6 &gt; #5 &gt; #4 &gt; #2 &gt; #1。 通过 git check-attr 查看 .gitattribute文件内容信息，命令参考 git check-attr。 .gitkeep了解 git 底层原理的人应该比较清楚，git 无法追踪一个空的文件夹，当用户需要追踪(track)一个空的文件夹的时候，按照惯例，大家会把一个称为 .gitkeep 的文件放在这些文件夹里。 .gitmodulesgit 子仓库（submodules）。 .git/description.git/description 文件用来存储仓库名称以及仓库的描述信息。默认的值为： 1Unnamed repository; edit this file &#39;description&#39; to name the repository. 也可以改成类似如下的值： 1git-inside This is git-inside 有些Git 工具（比如 GitWeb ）通过读取该文件来获取仓库名称以及仓库的说明信息。git hooks 也会读取 .git/description 来获取仓库名称。","categories":[],"tags":[]},{"title":"Git Cheatsheet","slug":"git-cheatsheet","date":"2020-10-20T01:57:37.000Z","updated":"2021-02-16T08:42:24.000Z","comments":true,"path":"2020/10/20/git-cheatsheet/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/20/git-cheatsheet/","excerpt":"","text":"Git Cheatsheet 更多 git cheatsheet 可以看 https://github.com/arslanbilal/git-cheat-sheet 。 git cheatsheet Gitlab 官方提供的 git cheatsheet 。 git revisions cheatsheet 出自 Rico’s cheatsheets - git revisions 。 git 各个区的关系 出自 http://amio.github.io/git-cheatsheet-chs/#loc=remote_repo; 。","categories":[],"tags":[]},{"title":"Git Hooks","slug":"git-hooks","date":"2020-10-20T01:57:37.000Z","updated":"2021-02-16T08:42:24.000Z","comments":true,"path":"2020/10/20/git-hooks/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/20/git-hooks/","excerpt":"","text":"Git Hooks 官方Git 钩子说明：https://git-scm.com/docs/githooks 。 Git 能在特定的重要动作发生时触发自定义脚本，该脚本可以是Shell、Ruby、Python等，这些脚本就是 Git Hooks（git 钩子）。钩子都被存储在 Git 工作目录下的 hooks 子目录中： 12345678910111213141516$ tree .git/hooks.git/hooks├── applypatch-msg.sample├── commit-msg.sample├── fsmonitor-watchman.sample├── post-update.sample├── pre-applypatch.sample├── pre-commit.sample├── pre-merge-commit.sample├── pre-push.sample├── pre-rebase.sample├── pre-receive.sample├── prepare-commit-msg.sample└── update.sample0 directories, 12 files git hooks 的生命周期图解： 该图片来自：https://delicious-insights.com/fr/articles/git-hooks/ 。 提交工作流的钩子 hook 触发点 说明 pre-commit 提交信息前运行 它用于检查即将提交的快照，如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit --no-verify 来绕过这个环节。 prepare-commit-msg 在启动提交信息编辑器之前，默认信息被创建之后运行 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。 commit-msg 提交信息时运行 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。 post-commit 整个提交过程完成后运行 它不接收任何参数，但你可以很容易地通过运行 git log -1 HEAD 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。 电子邮件工作流钩子 hook 触发点 说明 applypatch-msg 应用补丁前运行 它接收单个参数：包含请求合并信息的临时文件的名字。 如果脚本返回非零值，Git 将放弃该补丁。 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。 pre-applypatch 应用补丁后、产生提交之前运 你可以用这个脚本运行测试或检查工作区。 如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交。 post-applypatch 提交产生后运行 git am 运行期间最后被调用的钩子。 你可以用它把结果通知给一个小组或所拉取的补丁的作者。 但你没办法用它停止打补丁的过程。 其他客户端钩子 hook 触发点 说明 pre-rebase rebase 前 以非零值退出可以中止变基的过程。 你可以使用这个钩子来禁止对已经推送的提交变基。 post-rewrite 运行会替换提交记录的命令时调用 比如：git commit --amend 和 git rebase。它唯一的参数是触发重写的命令名，同时从标准输入中接受一系列重写的提交记录。 这个钩子的用途很大程度上跟 post-checkout 和 post-merge 差不多。 post-checkout 在 git checkout 成功运行后 你可以根据你的项目环境用它调整你的工作目录。 其中包括放入大的二进制文件、自动生成文档或进行其他类似这样的操作。 post-merge 在 git merge 成功运行后 你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。 这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。 pre-push 在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用 它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。 你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。 pre-auto-gc 在垃圾回收（git gc --auto）开始之前被调用 可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。 服务端钩子 hook 触发点 说明 pre-receive 来自客户端的推送操作时 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。 update update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。 post-receive 整个接收过程完结以后运行 可以用来更新其他系统服务或者通知用户。 它接受与 pre-receive 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器， 或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态， 所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。","categories":[],"tags":[]},{"title":"Git Revisions","slug":"git-revisions","date":"2020-10-20T01:57:37.000Z","updated":"2021-02-17T03:33:02.000Z","comments":true,"path":"2020/10/20/git-revisions/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/20/git-revisions/","excerpt":"","text":"Git Revisions 参考原文链接：https://git-scm.com/docs/gitrevisions 。 git revisions （Git 修订版本）代表特定的版本或范围，revisions 可以高效的定位你想要的提交，git 命令很多参数都支持 revisions 。 revisions 的具体格式有一整套匹配规则： 1234567891011121314151617181920212223242526----------------------------------------------------------------------| Commit-ish/Tree-ish | Examples----------------------------------------------------------------------| 1. &lt;sha1&gt; | dae86e1950b1277e545cee180551750029cfe735| 2. &lt;describeOutput&gt; | v1.7.4.2-679-g3bee7fb| 3. &lt;refname&gt; | master, heads/master, refs/heads/master| 4. &lt;refname&gt;@&#123;&lt;date&gt;&#125; | master@&#123;yesterday&#125;, HEAD@&#123;5 minutes ago&#125;| 5. &lt;refname&gt;@&#123;&lt;n&gt;&#125; | master@&#123;1&#125;| 6. @&#123;&lt;n&gt;&#125; | @&#123;1&#125;| 7. @&#123;-&lt;n&gt;&#125; | @&#123;-1&#125;| 8. &lt;refname&gt;@&#123;upstream&#125; | master@&#123;upstream&#125;, @&#123;u&#125;| 9. &lt;rev&gt;^ | HEAD^, v1.5.1^0| 10. &lt;rev&gt;~&lt;n&gt; | master~3| 11. &lt;rev&gt;^&#123;&lt;type&gt;&#125; | v0.99.8^&#123;commit&#125;| 12. &lt;rev&gt;^&#123;&#125; | v0.99.8^&#123;&#125;| 13. &lt;rev&gt;^&#123;/&lt;text&gt;&#125; | HEAD^&#123;/fix nasty bug&#125;| 14. :/&lt;text&gt; | :/fix nasty bug----------------------------------------------------------------------| Tree-ish only | Examples----------------------------------------------------------------------| 15. &lt;rev&gt;:&lt;path&gt; | HEAD:README.txt, master:sub-directory/----------------------------------------------------------------------| Tree-ish? | Examples----------------------------------------------------------------------| 16. :&lt;n&gt;:&lt;path&gt; | :0:README, :README---------------------------------------------------------------------- 来自 StackOverflow 的 一份回答：What are commit-ish and tree-ish in Git? 。 &lt;sha1&gt;object 对象名称。示例： dae86e1950b1277e545cee180551750029cfe735 dae86e &lt;describeOutput&gt;git describe 的输出。 示例： v1.7.4.2-679-g3bee7fb &lt;refname&gt;引用名称。 示例： master heads/master refs/heads/master @单独一个 @ 表示 HEAD ，及当前分支。 [&lt;refname&gt;]@&#123;&lt;date&gt;&#125;设置引用名称，同时设置时间过滤条件。 示例： master@&#123;yesterday&#125; HEAD@&#123;5 minutes ago&#125; refs/heads/master@&#123;1979-02-26 18:30:00&#125; &lt;refname&gt;@&#123;&lt;n&gt;&#125;设置引用名称，同时设置倒数第 n 个版本。 0 代表最新的版本。 示例： HEAD@&#123;0&#125; master@&#123;1&#125; refs/heads/master@&#123;10&#125; @&#123;&lt;n&gt;&#125;跟 &lt;refname&gt;@&#123;&lt;n&gt;&#125; 一样，省略了 refname 表示 refname 默认为 HEAD 。 @&#123;-&lt;n&gt;&#125;[&lt;branchname&gt;]@&#123;upstream&#125;指定远程仓库分支名称。@&#123;upstream&#125; 可以简化成 @&#123;u&#125; 。 示例： master@&#123;upstream&#125; @&#123;u&#125; [&lt;branchname&gt;]@&#123;push&#125;指定分支名称，指示该分支将会push到远程仓库中。 示例： master@&#123;push&#125; @&#123;push&#125; &lt;rev&gt;^[&lt;n&gt;]在 revision 后面添加 ^ 符号，表示获取第 n 个父级对象( parent )，没有设置 n 时，表示第一个父级对象，^0 表示 commit 本身。 示例： HEAD^ v1.5.1^0 HEAD^3 &lt;rev&gt;~[&lt;n&gt;]&lt;rev&gt;^&#123;&lt;type&gt;&#125;在 revision 后面添加 ^&#123;&lt;type&gt;&#125; 符号表示递归该引用直到找到对应类型（_&lt;type&gt;_）的 object 对象。 示例： v0.99.8^&#123;commit&#125; dae86e1950b1277e545cee180551750029cfe735^&#123;tree&#125; &lt;rev&gt;^&#123;&#125;表示递归该引用直到找到类型为tag的 object 对象。 示例： v0.99.8^&#123;&#125; dae86e1950b1277e545cee180551750029cfe735^&#123;&#125; &lt;rev&gt;^&#123;/&lt;text&gt;&#125;匹配 &lt;text&gt;_，等效于 _:/&lt;text&gt; 。 示例： HEAD^&#123;/fix nasty bug&#125; :/&lt;text&gt;正则表达式匹配字符串。 示例： :/fix nasty bug :/^foo &lt;rev&gt;:&lt;path&gt;匹配文件/目录名称。 示例： HEAD:README master:./README :[&lt;n&gt;:]&lt;path&gt;","categories":[],"tags":[]},{"title":"Git 的特殊技巧","slug":"git-tips","date":"2020-10-20T01:57:37.000Z","updated":"2021-02-17T07:55:20.000Z","comments":true,"path":"2020/10/20/git-tips/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/20/git-tips/","excerpt":"","text":"Git 的特殊技巧 可以 clone 本地仓库1$ git clone /home/git/repositories/801/038/000/38801.git 修改本地提交者信息 本地有 Untracked Files 时，如何做一个 patch 包123456# -N 表示实际上并没有把文件添加到暂存区$ git add -N .# git diff 生成 patch 文件$ git diff &gt; xxx.patch# 恢复$ git reset 如下显示： git clone –bare1234567891011121314151617181920212223242526272829$ git clone --bare git@github.com:xiaowenxia/git-inside.gitCloning into bare repository &#x27;git-inside.git&#x27;......# 查看目录$ tree git-inside.git git-inside.git|-- HEAD|-- branches|-- config|-- description|-- hooks| |-- applypatch-msg.sample| |-- ......| |-- prepare-commit-msg.sample| `-- update.sample|-- info| `-- exclude|-- objects| |-- info| `-- pack| |-- pack-0381ae2bc198d3ad1f6483eaf2ebf80fe6cd9b26.idx| `-- pack-0381ae2bc198d3ad1f6483eaf2ebf80fe6cd9b26.pack|-- packed-refs`-- refs |-- heads `-- tags9 directories, 18 files 查看 commit-id 属于哪个分支123$ git branch -r --contains e784be434c9133cef107185925af22cd620a8e5eorigin/feature/wikiorigin/releases/20201015194918032_r_release_62648_t-force-stone-code 查看某人的所有提交（所有分支）123456789101112$ git log --all --author=&quot;775117471@qq.com&quot;commit 59cabcd911a3a7460d53c850ee2c69372397cec9 (HEAD -&gt; main, origin/main, origin/HEAD)Author: xiaowenxia &lt;775117471@qq.com&gt;Date: Tue Nov 3 20:07:30 2020 +0800 add some git tipscommit 834afb32e8e9825e80c7910dbd9379e1be77629aAuthor: xiaowenxia &lt;775117471@qq.com&gt;Date: Mon Nov 2 15:09:43 2020 +0800 Add `git-refs`. 如何在 vscode 中查看已经提交的代码 diff因为 vscode 查看代码 diff 非常方便，比 git 默认的编辑器查看 diff 方便很多。 12345# reset 到前面 7 个提交$ git reset --soft HEAD~7# 恢复$ git pull 如下所示： cherry-pick 多个提交12345# 中间使用三个点（...）代表 pick 多个提交，这些提交必须是连续的$ git cherry-pick 33fbcded...4f17fa9f# 不连续的提交则需要单独指定 commit-id$ git cherry-pick 33fbcded 4f17fa9f 820b38b4 指定 git 仓库路径1$ git -C ~/workspace/github/git-inside status 指定 git 的工作目录1$ git --git-dir=~/workspace/github/git-inside/.git status git 的一些数据统计命令 统计的是 git 的仓库：https://github.com/git/git 。 统计仓库里面提交次数123456789101112131415161718# 统计每个人的提交次数$ git log | grep &quot;^Author: &quot; | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c | sort -k1,1nr22110 Junio3685 Jeff1824 Nguyễn...... # 省略 680 Brandon 524 Jakub...... # 省略 1 Андрей# 统计 Junio 的提交次数$ git log | grep &quot;^Author: .*&lt;gitster@pobox.com&gt;&quot; | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c | sort -k1,1nr22110 Junio# 或者$ git log --author=gitster@pobox.com --oneline | wc -l 22110 按月统计指定用户的提交次数12$ git log --author=gitster@pobox.com --since=&quot;2020-07-01&quot; --no-merges | grep -e &#x27;commit [a-zA-Z0-9]*&#x27; | wc -l 79 统计仓库所有提交次数1234567# 统计指定分支的提交次数$ git log --oneline | wc -l 61128# 统计所有分支的提交次数$ git log --oneline --all | wc -l 63541 统计指定用户的代码量1234567# 当前分支$ git log --author=&quot;gitster@pobox.com&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#x27; -added lines: 232482, removed lines: 101841, total lines: 130641# 所有分支$ git log --author=&quot;gitster@pobox.com&quot; --pretty=tformat: --numstat --all | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#x27; -added lines: 549564, removed lines: 376991, total lines: 172573 如何快速克隆 github 上的源码github 在国内的 clone 速度是非常慢的，速率一般在100k以下，如果要 clone 相对比较大的项目那会非常痛苦，而且git clone 没有断点续传功能，网络中断的话则需要重新clone。此时可以利用 gitee。gitee 在国内的访问速度非常快，达到 4~5M 的 clone 速率，而且针对 github 上部分大型且比较有名的项目，gitee都会做一个仓库镜像，该镜像会每日同步，具体可以访问 Gitee 极速下载。所以要快速克隆 github 上的源码，可以进行如下操作： 123456789101112# 首先 git clone gitee 的国内 git 镜像仓库。$ git clone git@gitee.com:mirrors/AliOS-Things.git# 再添加一个新的 remote 仓库为 github 的仓库。$ cd AliOS-Things$ git remote add github git@github.com:alibaba/AliOS-Things.git# 然后 git fetch --all 就可以把 github 的仓库快速 clone 下来。$ git fetch –all# 新建 github 的本地分支，也可以删除掉 gitee 远程仓库。$ git checkout –b github_rel_3.0.0 –track github/rel_3.0.0 操作示例如下： 为什么 git 仓库提交历史很难篡改？git 的底层 chain 对象和区块链有异曲同工之处，都是基于 merkle tree 的链式。 区块链如何运用merkle tree验证交易真实性 vscode 里面的git 管理具体是怎么实现的？git 为什么要使用sha256？ git hash object的作用 sha1的优势劣势 git gc 具体做了哪些事情？Git 顶层设计很优雅，Git 有140个 “小而美” 的子命令。写一个工具，把git 对象绘制成图。如何铺满整个github 的 contributions 计数面板定义你的 github 贡献日历图 代码如下： 123456789101112131415timestampFile=timestamp.logtouch $timestampFilefor ((k=0; k&lt;365; k++))do # 生成过去一年的随机时间 timestamp=`date -d &quot;-$[RANDOM%365] day -$[RANDOM%24] hour -$[RANDOM%60] minute -$[RANDOM%60] second &quot; &quot;+%Y-%m-%d %H:%M:%S&quot;` # 随机提交 1~5 次 for ((i=0; i&lt;=$[RANDOM%5]; i++)) do echo $timestamp &gt;&gt; $timestampFile git add $timestampFile git commit --date=&quot;&#123;$i&#125;$&#123;timestamp&#125;&quot; -m &quot;&#123;$i&#125;$&#123;timestamp&#125;&quot; donedone","categories":[],"tags":[]},{"title":"Git 工作流","slug":"git-workflow","date":"2020-10-20T01:57:37.000Z","updated":"2021-02-16T07:00:09.000Z","comments":true,"path":"2020/10/20/git-workflow/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/20/git-workflow/","excerpt":"","text":"Git 工作流","categories":[],"tags":[]},{"title":"Git 底层命令","slug":"git-internal-commands","date":"2020-10-20T01:57:37.000Z","updated":"2021-02-19T11:35:46.000Z","comments":true,"path":"2020/10/20/git-internal-commands/","link":"","permalink":"https://xiaowenxia.github.io/git-inside/2020/10/20/git-internal-commands/","excerpt":"","text":"Git 底层命令 目录 git cat-file git ls-files git ls-tree git read-tree git write-tree git commit-tree git mktree git diff-tree git gc git verify-pack git hash-object git show-index git show-ref git update-ref git rev-parse git rev-list git for-each-ref git var git diff-tree git merge-base git ref-log git blame git check-attr git count-objects git fsck git 的子命令可以通过 git --exec-path 可以获取到 git 的子命令存储目录，如下显示： 12345678910111213141516171819202122232425262728$ ls `git --exec-path`git git-count-objects git-help git-mergetool git-remote-fd git-stashgit-add git-credential git-http-backend git-mergetool--lib git-remote-ftp git-statusgit-add--interactive git-credential-cache git-http-fetch git-mktag git-remote-ftps git-stripspacegit-am git-credential-cache--daemon git-http-push git-mktree git-remote-http git-submodulegit-annotate git-credential-store git-imap-send git-mv git-remote-https git-submodule--helpergit-apply git-daemon git-index-pack git-name-rev git-remote-testsvn git-subtreegit-archive git-describe git-init git-notes git-repack git-symbolic-refgit-bisect git-diff git-init-db git-pack-objects git-replace git-taggit-bisect--helper git-diff-files git-instaweb git-pack-redundant git-request-pull git-unpack-filegit-blame git-diff-index git-interpret-trailers git-pack-refs git-rerere git-unpack-objectsgit-branch git-diff-tree git-log git-parse-remote git-reset git-update-indexgit-bundle git-difftool git-ls-files git-patch-id git-rev-list git-update-refgit-cat-file git-difftool--helper git-ls-remote git-prune git-rev-parse git-update-server-infogit-check-attr git-fast-export git-ls-tree git-prune-packed git-revert git-upload-archivegit-check-ignore git-fast-import git-mailinfo git-pull git-rm git-upload-packgit-check-mailmap git-fetch git-mailsplit git-push git-send-pack git-vargit-check-ref-format git-fetch-pack git-merge git-quiltimport git-sh-i18n git-verify-commitgit-checkout git-filter-branch git-merge-base git-read-tree git-sh-i18n--envsubst git-verify-packgit-checkout-index git-fmt-merge-msg git-merge-file git-rebase git-sh-prompt git-verify-taggit-cherry git-for-each-ref git-merge-index git-rebase--am git-sh-setup git-web--browsegit-cherry-pick git-format-patch git-merge-octopus git-rebase--helper git-shell git-whatchangedgit-clean git-fsck git-merge-one-file git-rebase--interactive git-shortlog git-worktreegit-clone git-fsck-objects git-merge-ours git-rebase--merge git-show git-write-treegit-column git-gc git-merge-recursive git-receive-pack git-show-branch mergetoolsgit-commit git-get-tar-commit-id git-merge-resolve git-reflog git-show-indexgit-commit-tree git-grep git-merge-subtree git-remote git-show-refgit-config git-hash-object git-merge-tree git-remote-ext git-stage git cat-file查看objects文件。 命令说明（点击展开） usage: git cat-file (-t [--allow-unknown-type] | -s [--allow-unknown-type] | -e | -p | &lt;type&gt; | --textconv | --filters) [--path=&lt;path&gt;] &lt;object&gt; or: git cat-file (--batch | --batch-check) [--follow-symlinks] [--textconv | --filters] &lt;type&gt; can be one of: blob, tree, commit, tag -t show object type -s show object size -e exit with zero when there&#39;s no error -p pretty-print object&#39;s content --textconv for blob objects, run textconv on object&#39;s content --filters for blob objects, run filters on object&#39;s content --path &lt;blob&gt; use a specific path for --textconv/--filters --allow-unknown-type allow -s and -t to work with broken/corrupt objects --buffer buffer --batch output --batch[=&lt;format&gt;] show info and content of objects fed from the standard input --batch-check[=&lt;format&gt;] show info about objects fed from the standard input --follow-symlinks follow in-tree symlinks (used with --batch or --batch-check) --batch-all-objects show all objects with --batch or --batch-check 示例 123456789101112131415161718192021222324252627# 查看 objects 文件类型$ git cat-file -t 56ec1a0729533fbd8d38b7964b6f8ca2cace70bacommit# 查看 objects 文件大小$ git cat-file -s 56ec1a0729533fbd8d38b7964b6f8ca2cace70ba243# 查看 objects 文件（格式化）内容$ git cat-file -p 56ec1a0729533fbd8d38b7964b6f8ca2cace70batree 7f9adb36c3e987d1ca9d40ba538afd8cbc74e942parent cf22ff3d15d718603f93c36f13d848e00d841defauthor chenan.xxw &lt;chenan.xxw@alibaba-inc.com&gt; 1599545250 +0800committer chenan.xxw &lt;chenan.xxw@alibaba-inc.com&gt; 1599545250 +0800update README.md# 也可以通过 tag 或 branch 名称查看 object 文件$ git cat-file -t v0.1.0tag$ git cat-file -p v0.1.0object c5b97d5ae6c19d5c5df71a34c7fbeeda2479ccbctype committag v0.1.0tagger Scott Chacon &lt;schacon@gmail.com&gt; 1290556430 -0800tagging initial release of libgit2 git ls-files查看index文件内容。 命令说明（点击展开） usage: git ls-files [&lt;options&gt;] [&lt;file&gt;...] -z paths are separated with NUL character -t identify the file status with tags -v use lowercase letters for &#39;assume unchanged&#39; files -f use lowercase letters for &#39;fsmonitor clean&#39; files -c, --cached show cached files in the output (default) -d, --deleted show deleted files in the output -m, --modified show modified files in the output -o, --others show other files in the output -i, --ignored show ignored files in the output -s, --stage show staged contents&#39; object name in the output -k, --killed show files on the filesystem that need to be removed --directory show &#39;other&#39; directories&#39; names only --eol show line endings of files --empty-directory don&#39;t show empty directories -u, --unmerged show unmerged files in the output --resolve-undo show resolve-undo information -x, --exclude &lt;pattern&gt; skip files matching pattern -X, --exclude-from &lt;file&gt; exclude patterns are read from &lt;file&gt; --exclude-per-directory &lt;file&gt; read additional per-directory exclude patterns in &lt;file&gt; --exclude-standard add the standard git exclusions --full-name make the output relative to the project top directory --recurse-submodules recurse through submodules --error-unmatch if any &lt;file&gt; is not in the index, treat this as an error --with-tree &lt;tree-ish&gt; pretend that paths removed since &lt;tree-ish&gt; are still present --abbrev[=&lt;n&gt;] use &lt;n&gt; digits to display SHA-1s --debug show debugging data 示例 1234567891011121314151617$ git ls-files.gitignoreMakefileREADMEREADME.mdcache.hcat-file.ccommit-tree.cinit-db.cread-cache.cread-tree.cshow-diff.cupdate-cache.cwrite-tree.c# 使用 hexdump 可以查看到index文件内容$ hexdump -C .git/index git ls-tree查看树内容，可以是 commit-id ，也可以是 tree-id ，也可以是 git revisions 格式。 命令说明（点击展开） usage: git ls-tree [&lt;options&gt;] &lt;tree-ish&gt; [&lt;path&gt;...] -d only show trees -r recurse into subtrees -t show trees when recursing -z terminate entries with NUL byte -l, --long include object size --name-only list only filenames --name-status list only filenames --full-name use full path names --full-tree list entire tree; not just current directory (implies --full-name) --abbrev[=&lt;n&gt;] use &lt;n&gt; digits to display SHA-1s 示例 123456789101112131415161718192021$ git ls-tree bace6b8b2d3058e3cc0495f5edfb235ed8cff21e100644 blob c30106543ed8f32af334362fa82e3a4ad71ef20f home.md100644 blob c3d45c3c479ebc458accbbd82c6483aecb35e516 main.md040000 tree fec352d6a6f669a3e1b035202911245e1d73e8ac subdir# size、全路径格式$ git ls-tree -l --full-name bace6b8b2d3058e3cc0495f5edfb235ed8cff21e100644 blob c30106543ed8f32af334362fa82e3a4ad71ef20f 16 home.md100644 blob c3d45c3c479ebc458accbbd82c6483aecb35e516 18 main.md040000 tree fec352d6a6f669a3e1b035202911245e1d73e8ac - subdir$ git ls-tree --full-name HEAD100644 blob c30106543ed8f32af334362fa82e3a4ad71ef20f home.md100644 blob c3d45c3c479ebc458accbbd82c6483aecb35e516 main.md040000 tree fec352d6a6f669a3e1b035202911245e1d73e8ac subdir# git revision 格式$ git ls-tree --full-name HEAD^&#123;tree&#125;100644 blob c30106543ed8f32af334362fa82e3a4ad71ef20f home.md100644 blob c3d45c3c479ebc458accbbd82c6483aecb35e516 main.md040000 tree fec352d6a6f669a3e1b035202911245e1d73e8ac subdir git read-tree把tree的信息（可以是多个）写入到索引（index）中。 命令说明（点击展开） usage: git read-tree [(-m [--trivial] [--aggressive] | --reset | --prefix=&lt;prefix&gt;) [-u [--exclude-per-directory=&lt;gitignore&gt;] | -i]] [--no-sparse-checkout] [--index-output=&lt;file&gt;] (--empty | &lt;tree-ish1&gt; [&lt;tree-ish2&gt; [&lt;tree-ish3&gt;]]) --index-output &lt;file&gt; write resulting index to &lt;file&gt; --empty only empty the index -v, --verbose be verbose Merging -m perform a merge in addition to a read --trivial 3-way merge if no file level merging required --aggressive 3-way merge in presence of adds and removes --reset same as -m, but discard unmerged entries --prefix &lt;subdirectory&gt;/ read the tree into the index under &lt;subdirectory&gt;/ -u update working tree with merge result --exclude-per-directory &lt;gitignore&gt; allow explicitly ignored files to be overwritten -i don&#39;t check the working tree after merging -n, --dry-run don&#39;t update the index or the work tree --no-sparse-checkout skip applying sparse checkout filter --debug-unpack debug unpack-trees --recurse-submodules[=&lt;checkout&gt;] control recursive updating of submodules 示例 123456789$ git read-tree 7fc6c35263716bad0d1df5a814766e8f1fd20345$ git ls-fileshome.mdmain.mdsubdir/deeper.md$ git read-tree HEAD^home.mdmain.md git write-tree把存储区的文件结构存储成 tree 对象。 命令说明（点击展开） usage: git write-tree [–missing-ok] [–prefix=/] --missing-ok allow missing objects --prefix &lt;prefix&gt;/ write tree object for a subdirectory &lt;prefix&gt; 1# 待补充 git commit-tree把 tree 对象读取到暂存区。 命令说明（点击展开） usage: git commit-tree [(-p )…] [-S[]] [-m ] [-F ] 1# 待补充 git mktree根据输入（ls-tree的输出格式）来生成 tree 对象。 命令说明（点击展开） usage: git mktree [-z] [–missing] [–batch] -z input is NUL terminated --missing allow missing objects --batch allow creation of more than one tree 1# 待补充 ### git diff-tree 比较 2 个tree 对象 的差异并格式化输出。 命令说明（点击展开） usage: git diff-tree [–stdin] [-m] [-c] [–cc] [-s] [-v] [–pretty] [-t] [-r] [–root] [] [] […] -r diff recursively –root include the initial commit as diff against /dev/null common diff options: -z output diff-raw with lines terminated with NUL. -p output patch format. -u synonym for -p. –patch-with-raw output both a patch and the diff-raw format. –stat show diffstat instead of patch. –numstat show numeric diffstat instead of patch. –patch-with-stat output a patch and prepend its diffstat. –name-only show only names of changed files. –name-status show names and status of changed files. –full-index show full object name on index lines. –abbrev= abbreviate object names in diff-tree header and diff-raw. -R swap input file pairs. -B detect complete rewrites. -M detect renames. -C detect copies. –find-copies-harder try unchanged files as candidate for copy detection. -l limit rename attempts up to paths. -O reorder diffs according to the . -S find filepair whose only one side contains the string. –pickaxe-all show all files diff when -S is used and hit is found. -a –text treat all files as text. 1# 待补充 git gc打包压缩操作，将多个 object 对象打包成 pack 文件对象。 命令说明（点击展开） usage: git gc [&lt;options&gt;] -q, --quiet suppress progress reporting --prune[=&lt;date&gt;] prune unreferenced objects --aggressive be more thorough (increased runtime) --auto enable auto-gc mode --force force running gc even if there may be another gc running --keep-largest-pack repack all other packs except the largest pack 12345678$ git gcEnumerating objects: 43, done.Counting objects: 100% (43/43), done.Delta compression using up to 12 threadsCompressing objects: 100% (43/43), done.Writing objects: 100% (43/43), done.Total 43 (delta 15), reused 26 (delta 0)Computing commit graph generation numbers: 100% (10/10), done. git verify-pack查看 pack 包内容。 命令说明（点击展开） usage: git verify-pack [-v | --verbose] [-s | --stat-only] &lt;pack&gt;... -v, --verbose verbose -s, --stat-only show statistics only 示例 1234567891011121314151617181920212223# 查看简略信息$ git verify-pack -s objects/pack/pack-eebc99ef678d342a5e2aa34c32ec21e488f3bc32.idxnon delta: 28 objectschain length = 1: 2 objectschain length = 2: 11 objectschain length = 3: 2 objects# 查看详细内容$ git verify-pack -v objects/pack/pack-eebc99ef678d342a5e2aa34c32ec21e488f3bc32.idxb0316411f58dc6dd18c700e04f9d3f7f99c17c41 commit 243 162 1256ec1a0729533fbd8d38b7964b6f8ca2cace70ba commit 243 163 174cf22ff3d15d718603f93c36f13d848e00d841def commit 236 155 3371bac831942f9cd24f9ced4d8fe72988eb584f85c commit 233 153 4929b6e8ecd34cf3fc023123aaab660e58c4f6b705a commit 243 161 645......259a84fd251cdabdbbb93b382575fba00ea3614d blob 6170 2572 3345049cfa9e43a2a86952e2a93c5a8485da30d5dd306 blob 5423 2189 36022921f981353229db0c56103a52609d35aff16f41b blob 1441 741 38211non delta: 28 objectschain length = 1: 2 objectschain length = 2: 11 objectschain length = 3: 2 objectsobjects/pack/pack-eebc99ef678d342a5e2aa34c32ec21e488f3bc32.pack: ok git hash-object计算并生成 object 文件。 命令说明（点击展开） usage: git hash-object [-t &lt;type&gt;] [-w] [--path=&lt;file&gt; | --no-filters] [--stdin] [--] &lt;file&gt;... or: git hash-object --stdin-paths -t &lt;type&gt; object type -w write the object into the object database --stdin read the object from stdin --stdin-paths read file names from stdin --no-filters store file as is without filters --literally just hash any random garbage to create corrupt objects for debugging Git --path &lt;file&gt; process file as it were from this path --literally 参数：可以对任意数据（可能是垃圾数据）创建松散对象，防止被 git 阻止或过滤。这种方式主要用于调试 git。 示例 123456789# 仅计算内容的 hash 值$ echo &quot;test&quot; | git hash-object --stdin -w --literally9daeafb9864cf43055ae93beb0afd6c7d144bfa4# 计算内容的 hash 值并写入成 object 文件$ ll objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4-r--r--r-- 1 root root 20 Sep 28 09:55 objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4$ git cat-file -p 9daeafb9864cf43055ae93beb0afd6c7d144bfa4test git show-index从标准输入（stdio）中读取打包索引文件（*.idx）内容，解析并显示打包文件的索引信息。 命令说明（点击展开） usage: git show-index 示例 123456789101112$ cat .git/objects/pack/pack-b433cf40a267c0fd6b9c4b8afff213eb9ef4a6fe.idx | git show-index11588816 003e02611d63514e51b57eb6575e47475290ed26 (fe575e7e)11472110 00c99364e50d82189b7894fed6c6dda039cb1930 (55daba02)11271595 010f8bc628b084496e8ef448b87f05b938321793 (0ee48b3f)11499040 01122c9bab3033b286caf034e740429bda3910a3 (dc88ce00)9818594 01742e3d4d110b1dbbee737fe42deb834f61a682 (cff383fc)11589160 01afc6e92ae59469d19befb2dfe2083718e163dc (278f7124)10666903 01dc8ba07ced44ea1cb6bbf2372a9d77259cdc49 (d2cfe47d)10624256 01dfc33db0dd549a00d78daa612d827fd219f31d (2be74112)7243969 01f2ca67cc81936fed349cf46bcd58cc13ee7fcc (f31729b5)12537 02468694dfbbdf3e1535630afd2fc646c8de503d (96501cb8)...... git show-ref列出本地引用（ref）。 命令说明（点击展开） usage: git show-ref [-q | --quiet] [--verify] [--head] [-d | --dereference] [-s | --hash[=&lt;n&gt;]] [--abbrev[=&lt;n&gt;]] [--tags] [--heads] [--] [&lt;pattern&gt;...] or: git show-ref --exclude-existing[=&lt;pattern&gt;] --tags only show tags (can be combined with heads) --heads only show heads (can be combined with tags) --verify stricter reference checking, requires exact ref path --head show the HEAD reference, even if it would be filtered out -d, --dereference dereference tags into object IDs -s, --hash[=&lt;n&gt;] only show SHA1 hash using &lt;n&gt; digits --abbrev[=&lt;n&gt;] use &lt;n&gt; digits to display SHA-1s -q, --quiet do not print results to stdout (useful with --verify) --exclude-existing[=&lt;pattern&gt;] show refs from stdin that aren&#39;t in local repository 1234$ git show-ref52855ba8f5c7e8410db2277ca1b00c4e1d1c2721 refs/heads/master52855ba8f5c7e8410db2277ca1b00c4e1d1c2721 refs/remotes/origin/HEAD52855ba8f5c7e8410db2277ca1b00c4e1d1c2721 refs/remotes/origin/master git update-ref更新引用（ref）的内容为指定的对象名称或 sha1 值。 命令说明（点击展开） usage: git update-ref [&lt;options&gt;] -d &lt;refname&gt; [&lt;old-val&gt;] or: git update-ref [&lt;options&gt;] &lt;refname&gt; &lt;new-val&gt; [&lt;old-val&gt;] or: git update-ref [&lt;options&gt;] --stdin [-z] -m &lt;reason&gt; reason of the update -d delete the reference --no-deref update &lt;refname&gt; not the one it points to -z stdin has NUL-terminated arguments --stdin read updates from stdin --create-reflog create a reflog 1$ git update-ref HEAD 52855ba8f5c7e8410db2277ca1b00c4e1d1c2721 git rev-parse把 revisions 解析成 commit-id ，除此之外，还有其他的功能。 命令说明（点击展开） usage: git rev-parse --parseopt [&lt;options&gt;] -- [&lt;args&gt;...] or: git rev-parse --sq-quote [&lt;arg&gt;...] or: git rev-parse [&lt;options&gt;] [&lt;arg&gt;...] 123456789101112131415161718192021# 显示 revisions 的 sha1 值$ git rev-parse HEADde1acbdbcb7549b7eff8646f9d9cfb308d6bb90b$ git rev-parse master^&#123;tree&#125;06a04ed5cae14951e376336d8eadd59f75be3f9c# 显示git的工作目录$ git rev-parse --git-dir.git# 显示工作区目录$ git rev-parse --show-toplevel/Users/xxw/workspace/aone/force-stone# 显示相对于工作区根目录的相对路径$ cd vendor/github.com/pkg$ git rev-parse --show-prefixvendor/github.com/pkg/# 显示从当前目录(cd)后退(up)到工作区的根目录的深度$ git rev-parse --show-cdup../../../ git rev-list按照时间顺序输出历史的 commit-id 。 命令说明（点击展开） usage: git rev-list [OPTION] &lt;commit-id&gt;... [ -- paths... ] limiting output: --max-count=&lt;n&gt; --max-age=&lt;epoch&gt; --min-age=&lt;epoch&gt; --sparse --no-merges --min-parents=&lt;n&gt; --no-min-parents --max-parents=&lt;n&gt; --no-max-parents --remove-empty --all --branches --tags --remotes --stdin --quiet ordering output: --topo-order --date-order --reverse formatting output: --parents --children --objects | --objects-edge --unpacked --header | --pretty --[no-]object-names --abbrev=&lt;n&gt; | --no-abbrev --abbrev-commit --left-right --count special purpose: --bisect --bisect-vars --bisect-all 12345678910111213141516171819202122# 显示 master 分支的历史版本$ git rev-list master52855ba8f5c7e8410db2277ca1b00c4e1d1c2721b16a0f533bbda973eb28fbfbc91a7dbb345d38d1983f2892bebdaa7422895a2583cd32fab54c0ea57ba6884d2f1c40caf5ba40136c85c3c413c3488b585815f7b473f015cf99aeba71b5f37219494d903e17226d70bca16ff54647bda3444764c8062922174b8333509496687fa9baf570b0ebe4459289fb84c83efa85ddfa026d3db955dac212c3376bd10193af3cd9281510c1d64d806c30b77ca50894285932067c28ccc498b8059fb37823aedfb9a2d5527c# 显示 master 分支历史版本，同时显示 objects$ git rev-list master --objects...29885ee583595d9080b841625d7b2d16f0fb34d2 internal81a035a831bf13dc28cb86373e23c20d48b08c7c internal/diff05bb5447d0c6d121103ff75cfde889cd5f790794 internal/diff/diff.go7248748b8897d3e28421387b5133632c0cd772dd internal/servicea0995fd53aeb7748b7618e5427844bbedf20c832 internal/service/diff... git for-each-ref查看引用列表。 命令说明（点击展开） usage: git for-each-ref [&lt;options&gt;] [&lt;pattern&gt;] or: git for-each-ref [--points-at &lt;object&gt;] or: git for-each-ref [(--merged | --no-merged) [&lt;commit&gt;]] or: git for-each-ref [--contains [&lt;commit&gt;]] [--no-contains [&lt;commit&gt;]] -s, --shell quote placeholders suitably for shells -p, --perl quote placeholders suitably for perl --python quote placeholders suitably for python --tcl quote placeholders suitably for Tcl --count &lt;n&gt; show only &lt;n&gt; matched refs --format &lt;format&gt; format to use for the output --color[=&lt;when&gt;] respect format colors --sort &lt;key&gt; field name to sort on --points-at &lt;object&gt; print only refs which points at the given object --merged &lt;commit&gt; print only refs that are merged --no-merged &lt;commit&gt; print only refs that are not merged --contains &lt;commit&gt; print only refs which contain the commit --no-contains &lt;commit&gt; print only refs which don&#39;t contain the commit --ignore-case sorting and filtering are case insensitive 1234567$ git for-each-refccbe4719bd6d81a40343a97cfb49a094af30ccaf commit refs/heads/masterccbe4719bd6d81a40343a97cfb49a094af30ccaf commit refs/remotes/origin/HEAD785b6024cfa7e95359eb5b0fe8cfc7c8e6c4905e commit refs/remotes/origin/cmn/config-snapshotb63157de51a6caeffe067d3410b0a3f375b94390 commit refs/remotes/origin/cmn/go-http...... # 省略ccbe4719bd6d81a40343a97cfb49a094af30ccaf commit refs/tags/v31.3.0 git var查看 Git 当前生效的变量。 命令说明（点击展开） usage: git var (-l | ) 123456789101112131415$ git var -lcredential.helper=osxkeychaincolor.ui=auto# 省略alias.co=checkoutcore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=trueGIT_COMMITTER_IDENT=xiaowenxia &lt;775117471@qq.com&gt; 1607157829 +0800GIT_AUTHOR_IDENT=xiaowenxia &lt;775117471@qq.com&gt; 1607157829 +0800GIT_EDITOR=viGIT_PAGER=less git diff-tree比较 2 个tree 对象 的差异并格式化输出。 命令说明（点击展开） usage: git diff-tree [--stdin] [-m] [-c] [--cc] [-s] [-v] [--pretty] [-t] [-r] [--root] [&lt;common-diff-options&gt;] &lt;tree-ish&gt; [&lt;tree-ish&gt;] [&lt;path&gt;...] -r diff recursively --root include the initial commit as diff against /dev/null common diff options: -z output diff-raw with lines terminated with NUL. -p output patch format. -u synonym for -p. --patch-with-raw output both a patch and the diff-raw format. --stat show diffstat instead of patch. --numstat show numeric diffstat instead of patch. --patch-with-stat output a patch and prepend its diffstat. --name-only show only names of changed files. --name-status show names and status of changed files. --full-index show full object name on index lines. --abbrev=&lt;n&gt; abbreviate object names in diff-tree header and diff-raw. -R swap input file pairs. -B detect complete rewrites. -M detect renames. -C detect copies. --find-copies-harder try unchanged files as candidate for copy detection. -l&lt;n&gt; limit rename attempts up to &lt;n&gt; paths. -O&lt;file&gt; reorder diffs according to the &lt;file&gt;. -S&lt;string&gt; find filepair whose only one side contains the string. --pickaxe-all show all files diff when -S is used and hit is found. -a --text treat all files as text. 1234git diff-tree a0e96b5ee9f1a3a73f340ff7d1d6fe2031291bb0^&#123;tree&#125; 523d41ce82ea993e7c7df8be1292b2eac84d4659^&#123;tree&#125;:100644 000000 5664e303b5dc2e9ef8e14a0845d9486ec1920afd 0000000000000000000000000000000000000000 D README.md:040000 000000 39fb0fbcac51f66b514fbd589a5b2bc0809ce664 0000000000000000000000000000000000000000 D doc:100644 100644 aec2e48cbf0a881d893ccdd9c0d4bbaf011b5b23 6fb38b7118b554886e96fa736051f18d63a80c85 M file.txt git merge-base为合并找到共同祖先。 命令说明（点击展开） usage: git merge-base [-a | --all] &lt;commit&gt; &lt;commit&gt;... or: git merge-base [-a | --all] --octopus &lt;commit&gt;... or: git merge-base --independent &lt;commit&gt;... or: git merge-base --is-ancestor &lt;commit&gt; &lt;commit&gt; or: git merge-base --fork-point &lt;ref&gt; [&lt;commit&gt;] -a, --all output all common ancestors --octopus find ancestors for a single n-way merge --independent list revs not reachable from others --is-ancestor is the first one ancestor of the other? --fork-point find where &lt;commit&gt; forked from reflog of &lt;ref&gt; 1 git ref-log查看引用变更日志。 命令说明（点击展开） usage: git reflog [ show | expire | delete | exists ] 1234567$ git reflog2c5b80 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;0&#125;: commit: Update git commands539f806 HEAD@&#123;1&#125;: reset: moving to HEAD^bdff99c HEAD@&#123;2&#125;: commit: first commit539f806 HEAD@&#123;3&#125;: commit: add git-drawf5993a4 HEAD@&#123;4&#125;: commit: Add git-draw83c61eb HEAD@&#123;5&#125;: commit: Update readme.md git blame显示文件的每一个修改版本和作者。 命令说明（点击展开） usage: git blame [&lt;options&gt;] [&lt;rev-opts&gt;] [&lt;rev&gt;] [--] &lt;file&gt; &lt;rev-opts&gt; are documented in git-rev-list(1) --incremental Show blame entries as we find them, incrementally -b Show blank SHA-1 for boundary commits (Default: off) --root Do not treat root commits as boundaries (Default: off) --show-stats Show work cost statistics --progress Force progress reporting --score-debug Show output score for blame entries -f, --show-name Show original filename (Default: auto) -n, --show-number Show original linenumber (Default: off) -p, --porcelain Show in a format designed for machine consumption --line-porcelain Show porcelain format with per-line commit information -c Use the same output mode as git-annotate (Default: off) -t Show raw timestamp (Default: off) -l Show long commit SHA1 (Default: off) -s Suppress author name and timestamp (Default: off) -e, --show-email Show author email instead of name (Default: off) -w Ignore whitespace differences --indent-heuristic Use an experimental heuristic to improve diffs --minimal Spend extra cycles to find better match -S &lt;file&gt; Use revisions from &lt;file&gt; instead of calling git-rev-list --contents &lt;file&gt; Use &lt;file&gt;&#39;s contents as the final image -C[&lt;score&gt;] Find line copies within and across files -M[&lt;score&gt;] Find line movements within and across files -L &lt;n,m&gt; Process only line range n,m, counting from 1 --abbrev[=&lt;n&gt;] use &lt;n&gt; digits to display SHA-1s 12345678910111213$ git blame git-refs.md834afb32 (xiaowenxia 2020-11-02 15:09:43 +0800 1) a5cbb594 (xiaowenxia 2020-12-07 10:06:34 +0800 2) Git 引用本质上是指向特定的 commit 对象，git 默认情况下都会有一个 master 引用，指向一个默认的分支。a5cbb594 (xiaowenxia 2020-12-07 10:06:34 +0800 3) &gt; github 上已经把默认的分支从 `master` 改成了 `main` 分支。a5cbb594 (xiaowenxia 2020-12-07 10:06:34 +0800 4) a5cbb594 (xiaowenxia 2020-12-07 10:06:34 +0800 5) Git 还存在一个 `HEAD` 引用，代表当前工作的 tree。a5cbb594 (xiaowenxia 2020-12-07 10:06:34 +0800 6) a5cbb594 (xiaowenxia 2020-12-07 10:06:34 +0800 7) 834afb32 (xiaowenxia 2020-11-02 15:09:43 +0800 8) ```834afb32 (xiaowenxia 2020-11-02 15:09:43 +0800 9) $ tree .git/refs834afb32 (xiaowenxia 2020-11-02 15:09:43 +0800 10) .git/refs834afb32 (xiaowenxia 2020-11-02 15:09:43 +0800 11) ├── heads834afb32 (xiaowenxia 2020-11-02 15:09:43 +0800 12) │ └── master git check-attr查看文件属性。 命令说明（点击展开） usage: git check-attr [-a | –all | …] [–] … or: git check-attr –stdin [-z] [-a | –all | …] -a, --all report all attributes set on file --cached use .gitattributes only from the index --stdin read file names from stdin -z terminate input and output records by a NUL character 1# 待补充 git count-objects 命令说明（点击展开） usage: git count-objects [-v] [-H | –human-readable] -v, --verbose be verbose -H, --human-readable print sizes in human readable format 123456789101112131415$ git count-objects235 objects, 2220 kilobytes# 方便阅读$ git count-objects -H235 objects, 2.17 MiB# 详细$ git count-objects -Hvcount: 235size: 2.17 MiBin-pack: 4packs: 1size-pack: 2.42 KiBprune-packable: 0garbage: 0size-garbage: 0 bytes git fsck校验对象链表的正确性和有效性。 命令说明（点击展开） usage: git fsck [options] [object…] -v, --verbose be verbose --unreachable show unreachable objects --dangling show dangling objects --tags report tags --root report root nodes --cache make index objects head nodes --reflogs make reflogs head nodes (default) --full also consider packs and alternate objects --connectivity-only check only connectivity --strict enable more strict checking --lost-found write dangling objects in .git/lost-found --progress show progress --name-objects show verbose names for reachable objects 1234567891011121314151617181920212223# 当前git仓库是正确的$ git fsckChecking object directories: 100% (256/256), done.dangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904# 查看对象$ find .git/objects -type f.git/objects/60/8aeb44e919e3ed8264754851557b6f6f70fec8.git/objects/5a/3c92d2bc9622c5153110fd1ff1ec43646f2d52.git/objects/0f/9323931dbf812ac2d08afa6b094e17b60d2872.git/objects/30/13a8b53d3b92eb18c04e35e0757cfc29df9677.git/objects/2b/3f5d9b0f1a4381742cea304817c10a229cc53b.git/objects/34/dc7b21ed0493fd35da77730034967dce88fdc4.git/objects/4b/825dc642cb6eb9a060e54bf8d69288fbee4904# 改变其中一个对象$ echo &quot;&quot; &gt; .git/objects/60/8aeb44e919e3ed8264754851557b6f6f70fec8# 检查对象链表发现有错误$ git fsckerror: unable to unpack header of .git/objects/60/8aeb44e919e3ed8264754851557b6f6f70fec8error: 608aeb44e919e3ed8264754851557b6f6f70fec8: object corrupt or missing: .git/objects/60/8aeb44e919e3ed8264754851557b6f6f70fec8Checking object directories: 100% (256/256), done.error: unable to unpack 608aeb44e919e3ed8264754851557b6f6f70fec8 headererror: unable to unpack 608aeb44e919e3ed8264754851557b6f6f70fec8 headerfatal: loose object 608aeb44e919e3ed8264754851557b6f6f70fec8 (stored in .git/objects/60/8aeb44e919e3ed8264754851557b6f6f70fec8) is corrupt","categories":[],"tags":[]}],"categories":[],"tags":[]}